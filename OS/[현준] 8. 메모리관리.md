# 8. 메모리 관리
## 1. 메모리 계층 구조와 메모리 관리 핵심

### 메모리 계층 구조
⭐ 메모리는 컴퓨터 시스템에 여러 곳에서 계층적으로 존재

- CPU 레지스터, CPU 캐시, 외부 캐시 메모리, 메인 메모리, 보조기억 장치

![alt text](./[현준]%20Image/image-42.png)
![alt text](./[현준]%20Image/image-43.png)

### 메모리 계층화의 목적
- 컴퓨터 성능 향상 → 처리할 데이터도 대형화 → 저장 장치의 대형화 → 빠른 저장 장치 요구 → SSD 등장

- **메모리 계층화는 성능과 비용의 절충**

- 메모리 계층화의 목적 
    - CPU 메모리 액세스 시간을 줄이기 위함

    - 빠른 프로그램 실행을 위해

#### ✨ 상위 계층에 일부분의 내용을 복사하여 사용함

❓ : 일부분의 내용만 복사해도 효과적인가요?

❗ : 그럼요! **참조의 지역성** 때문입니다.
- 참조의 지역성 : **코드나 데이터, 자원등이 아주 짧은 시간** 내에 다시 사용되는 특성

- 캐시를 채우는 시간의 손해보다, 빠른 캐시를 이용하는 이득이 더 큼

<br>

### 참조의 지역성
- 공간 지역성 : 특정 블록의 참조가 집중적으로 이루어지면, **참조된 메모리 근처의 메모리를 참조**한다.

- 시간 지역성 : 최근 사용되었던 기억 장소들이 집중적으로 액세스 되는 경향으로, **참조했던 메모리는 빠른 시간에 다시 참조될 확률**이 높다.

- 순차 지역성 : 데이터가 순차적으로 액세스되는 경향으로, 프로그램 내의 명령어가 순차적으로 구성되어 있다는 것

<br>

### 메모리 관리
- CPU는 메모리에 적재된 코드와 데이터만을 처리함
<br>

❓ :  운영체제에 메모리 관리가 필요한 이유가 뭔가요?

- 메모리는 공유 자원이기 때문
    - 여러 프로세스들이 메모리를 공유

- 메모리는 보호되어야 하기 때문
    - 프로세스의 독립된 메모리 공간을 보장

- 메모리의 용량 한계를 극복할 필요가 있기 때문
    - 여러 프로세스의 메모리 합이 물리 메모리보다 큰 경우
- 메모리의 효율성 증대를 위해서
    - 가능하면 많은 개수의 프로세스를 실행시키기 위해서

<br>

## 2. 메모리 주소

### 물리 주소와 논리 주소
- 프로세스 / CPU와 물리 메모리 사이에서 실제로 사용하는 주소 개념

- **물리 주소**
    - 물리 메모리에 매겨진 주소, 고정된 메모리 주소

    - 0에서 시작하여 연속되는 주소 체계

- **논리/가상 주소**

    - 개발자나 프로세스가 프로세스 내에서 사용하는 주소

    - CPU 내부 주소도 논리 주소
        - CPU에서 사용하는 논리주소를 MMU가 물리주소로 변환해주어 CPU가 물리 메모리로 접근하게 함

    - 컴파일러와 링커에 의해 매겨진 주소

    - 사용자나 프로세스는 결코 물리 주소를 알 수 없음

<br>

### 절대 주소와 상대 주소
- **절대 주소** 
    - 상대 주소와 다르게 절대적인 위치를 의미하는 주소 체계

    - 물리 주소, CPU의 시스템 주소 버스를 이용하여 지정하는 물리적인 주소

- **상대 주소**
    - 프로세스의 논리 주소 공간에서 사용하는 논리 주소의 또 다른 표현

    - 임의의 주소를 기준으로 얼마만큼 떨어져 있는 지를 표현하는 상대적인 주소

<br>



### 상대 주소를 절대 주소로 변환하는 과정
- 상대 주소를 이용하여, 절대 주소로 변환해야하는 작업이 필요

- MMU는 상대 주소값에 `base 레지스터` 값을 더하여 물리 메모리의 절대 주소를 구함

<br>

### MMU (Memory Management Unit)
- 논리 주소를 물리 주소로 바꾸는 하드웨어 장치

- CPU 패키지 내부에 설계되어, 물리 주소로 바뀌어 물리 메모리에 도달함

![alt text](./[현준]%20Image/image-44.png)

<br>

### 컴파일과 논리 주소
- 컴파일러는 프로그램을 논리 주소로 컴파일함

- 운영프로그램 적재 시, 물리 메모리의 적절한 위치에 적재하고, 매핑 테이블을 생성함

- 응용프로그램 실행 시
    -  MMU는 CPU로부터 발생되는 **논리 주소를 물리 주소**로 변환

    - 동적 할당 받은 메모리의 주소, 스택 주소 역시 **논리 주소**

<br>

###  ASLR : 주소 공간 랜덤 배치

- 해커들의 메모리 공격에 대한 대비책

- **스택이나 힙, 라이브러리** 영역의 랜덤 배치
    - 실행할 때마다 논리 주소가 바뀌게 하는 기법

- 하지만, **코드나 데이터 영역**의 논리 주소는 바뀌지 않음

    ![alt text](./[현준]%20Image/image-45.png)

<br>

## 3. 물리 메모리 관리
### 메모리 할당
- 새 프로세스를 실행시키거나, 실행 중인 프로세스가 추가적인 메모리를 필요로 할 때, 물리 메모리를 할당함

- 메모리 할당은 전적으로 운영체제의 커널이 담당함

- 프로세스의 실행은 할당된 물리 메모리에서 이루어짐

#### 💡 원래는 부분 적재의 내용이 없지만, 오늘 배우는 내용은 부분 적재의 기능이 없다는 가정하에 공부

<br>

### 메모리 관리 기법 요약

#### [연속 메모리 할당]
💡 프로세스별로 연속된 한 덩어리로 메모리에 할당

![alt text](./[현준]%20Image/image-46.png)
- **고정 크기 할당** : 주 기적 장치가 고정된 파티션으로 분할

- **가변 크기 할당** : 파티션의 크기와 숫자가 동적으로 생성됨

#### [분할 메모리 할당]
💡 프로세스를 쪼개어 여러 덩어리로 분할해 메모리에 할당

![alt text](./[현준]%20Image/image-47.png)
- **페이징** : 균등 사이즈의 프레임으로 나뉘어, 모든 페이지가 적대되어야 한다.

- **세그먼테이션** : 여러 세그멘트로 나뉘어, 모든 세그먼트가 적재되고, 이 동적 파티션이연속적일 필요는 없다

- **가상 메모리 페이징** : 부분 적재가 가능 (필요하지 않은 페이지를 로드하지 않음)

- **가상 메모리 세그먼테이션** : 부분 적재가 가능 (필요하지 않은 세그먼트를 로드하지 않음)

<br>

## 4. 연속 메모리 할당
### 단편화
- 프로세스에게 할당할 수 없는 작은 조각 메모리들이 생기는 현상

- **내부 단편화** : 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상 (고정 크기 할당에서 발생)

    ![alt text](./[현준]%20Image/image-48.png)

- **외부 단편화** : 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상 (가변 크기 할당에서 발생)

    ![alt text](./[현준]%20Image/image-49.png)

    - 해결 방안

        - 메모리 압축 기법 : 중간에 비어있는 파티션을 이동하여 하나로 합침
        
            ![alt text](./[현준]%20Image/image-50.png)

        - 메모리 통합 기법 : 하나의 작업이 끝났을 때 다른 빈 공간과 인접한 공간을 하나로 합치는 것

            ![alt text](./[현준]%20Image/image-51.png)


<br>

### 메모리 관리 기본 구현
- CPU 메모리 할당과 관련된 레지스터
    - base 레지스터 : 실행중인 프로세스에게 할당된 **물리 메모리의 시작 주소**

    - 주소 레지스터 : CPU가 액세스하는 **논리 주소**

    - limit 레지스터 : 실행중인 프로세스에게 **할당된 메모리 크기** → 경계 레지스터

- MMU : 논리 주소를 물리 주소로 변환하는 장치
    - 메모리 보호 기능 : 프로세스에게 할당된 논리 주소 영역을 벗어나는지 여부 조사

<br>

### 메모리 관리의 기본 특성
- 재배치 : 프로세스가 메모리의 어느 위치에 올라가도 위치에 관계없이 실행이 가능해야 함

    - 상대 주소의 개념이 필요

    ![alt text](./[현준]%20Image/image-52.png)

- 보호 : 프로세스는 `다른 사용자 공간` or `커널 공간`을 접근하면 안됨

🔥 CPU, 운영체제, 컴파일러, 링커의 협업이 필요

<br>

### 홀 선택 알고리즘 / 동적 메모리 할당

- 메모리의 할당 리스트를 유지해야한다.

- **홀 선택 알고리즘**
    - 최초 적합  : 홀 리스트를 검색하여 처음으로 만나는 홀 선택, 내부 단편화 발생 가능성

    - 최적 적합  : 홀 리스트를 검색하여 가장 작은 홀 선택,  정렬이 필요함

    - 최악 적합 : 홀 리스트를 검색하여 가장 큰 홀 선택,  정렬이 필요함

<br>

### 연속 메모리 할당의 장단점

- 장점
    - 논리 주소의 물리 주소의 변환이 단순하여 CPU의 메모리 액세스 속도 빠름

    - 운영체제가 관리할 정보량이 적어서 부담이 덜함


- 단점
    - 메모리 할당의 유연성이 떨어짐 : 연속된 메모리 할당할 수 없는 경우 발생

    - 메모리 압축, 메모리 통합 기법으로 해결


<br>

## 5. 세그먼테이션 메모리 관리

### 세그먼테이션 개요

- 세그먼트 : 가변 크기로 할당되는 논리적 단위

- 세그먼테이션 기법
    - 프로세스를 논리 세그먼트들로 나누고, 각 논리 세그먼트를 물리 메모리에 할당하는 기법

    - 세그먼트 테이블을 두고 논리 주소를 물리 주소로 변환함
    
        ![alt text](./[현준]%20Image/image-53.png)

<br>

### 세그먼테이션의 구현
- 하드웨어 지원
    - 논리 주소의 구성 : 세그먼트 번호, 옵셋

    - CPU : 세그먼트 테이블의 시작 주소를 가리키는 레지스터 필요

    - MMU 장치 : 논리 주소를 물리 주소로 변환하는 장치

    - 세그먼트 테이블 : 메모리에 저장되며, 세그먼트 별로 시작 물리 주소와 세그먼트 크기 정보 저장

- 운영체제 지원 : 세그먼트의 동적 할당 / 반환 및 테이블 관리 기능

<br>

### 단편화

- 외부 단편화 발생 : 세그먼트 사이에 발생하는 작은 크기의 홀이 많이 생김

- 내부 단변화 발생 없음


