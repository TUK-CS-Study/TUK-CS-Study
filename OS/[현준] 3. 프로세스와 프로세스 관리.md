# 3장 프로세스와 프로세스 관리
## 1. 프로세스 개요
### 프로세스
> 프로그램이 메모리(주기억장치)에 적재되어 실행 중인 프로그램
<br>
<br>

### 프로세스의 특징
- 운영체제는 프로그램을 **메모리에 적재하고 프로세스로 다룸**

- 운영체제는 프로세스에게 실행에 필요한 **메모리를 할당**하고, 이곳에 **코드와 데이터 등 적재**
- 프로세스들은 **서로 독립적인 메모리 공간**을 가짐, 다른 프로세스 영역에 접근 불허

- 운영체제는 각 프로세스의 **메모리 위치와 크기 정보를 관리**한다.

- 프로세스는 **고유한 번호 - PID**를 가짐
- 프로세스의 관한 **모든 정보는 커널에 의해 관리**
- 프로세스는 실행 - 대기 - 잠자기 - 대기 - 실행 - 종료 등의 **생명 주기**를 가짐
<br>
<br>

### 프로세스 관리
- **프로세스의 생성에서 종료까지 관리는 모두 커널에 의해 만들어짐**
    
    - **프로세스 테이블**을 커널이 관리함
    
    - **프로세스 생성, 실행, 일시 중단 및 재개, 정보 관리, 프로세스 통신, 프로세스 동기화, 프로세스 중단, 컨택스트 스위칭** 등을 관리
<br>
<br>

### 프로세스 다중 인스턴스
- 프로그램 실행 시 마다 **독립된 프로세스들이 생성**됨

- 독립된 메모리 공간 할당하여, **별개의 프로세스로 취급**
![alt text](./[현준]%20Image/14.png)
<br>
<br>

### 프로세스의 사용자 공간과 커널 공간
- **프로세스 주소 공간 = 사용자 공간 + 커널 공간**

- **[사용자 공간]** 프로세스의 크기 : 코드 + 데이터 + 힙 + 스택
    - 코드 + 데이터 → **(고정)**

    - 힙 + 스택 → **(동적 할당)** 

- **[커널 공간]** 프로세스가 **시스템 호출**을 통해 이용하는 공간
    
    - **커널 코드, 커널 데이터, 커널 스택**이 존재함

- 모든 프로세스는 **각자의 사용자 공간이 존재**하고, **커널 공간**을 공유한다

![alt text](./[현준]%20Image/15.png)

💡프로세스의 주소 공간
- 물리(메모리) 주소 공간이 아닌 가상 공간이며, 프로세스의 주소는 **가상 주소**이다.

- 또한, 코드, 데이터, 힙, 스택이 물리 메모리에 **흩어져서 저장**됨

- **매핑 테이블**을 통해, 가상 주소를 물리 주소로 변환함

![alt text](./[현준]%20Image/16.png)

## 2. 커널의 프로세스 관리
### 프로세스 테이블과 프로세스 제어 블록
- **프로세스 테이블**
    - 시스템에 **단 하나**만 있음

    - 모든 **프로세스를 관리하기 위한 표**
- **프로세스 제어 블록**
    
    - **프로세스당 하나씩 존재**
    
    - **프로세스에 관한 정보를 저장하는 구조체**

    - 커널에 의해 생성, 저장, 읽혀지는 등 관리 
    - **구성 요소**
        - 프로세스 번호 : PID

        - 부모 프로세스 번호 : PPID
        - 프로세스 상태 : 준비, 실행 중, 블록
        - CPU 커텍스트 정보 : 코드 주소 및 레지스터
        - 스케줄링 정보 : 우선순위 값, nice 값, 스케줄 큐
        - 프로세스 종료 코드
        - 프로세스의 오픈 파일 테이블
        - 메모리 관리 정보 : 페이지 테이블의 물리 메모리 주소
        - 프로세스 사이의 통신 정보들
- 테이블 및 제어 블록 → **커널 영역**에 존재

<br>

### 프로세스 생명 주기와 상태 변이
![alt text](./[현준]%20Image/17.png)
- 상태 정보는 PCB에 기록되고, 상태가 바뀔 때마다 운영체제에 의해 갱신된다.

- 완전히 종료된 상태인 `Terminated/Out` 상태가 되면, PCB에서도 지워짐

**[프로세스 상태]**
- New : PCB에 등록, 메모리 할당 및 자원 적재
- Ready : 준비 완료, `준비 큐`에 대기하여 Running 상태가 되면 CPU에 의해 실행된
- Running : 현재 실행되는 상태
    - CPU의 시간할당량이 지나면 다시 Ready 상태로 바뀌고 준비 큐에 삽입
    
    - `입출력을 요청`하면, Block 상태로 만듬, `대기 큐`에 삽입

- Blocked/Wait : 입출력이 완료되면 프로세스는 `Ready` 상태로 바뀌고 `준비 큐`에 삽입
- Terminated/Zombie : 불완전 종료된 상태
    - 커널에 의해, 메모리와 할당 받은 자원들을 반환함

    - 프로세스 테이블의 항목과 PCB가 여전히 시스템에서 제거되지 않은 상태
- Terminated/Out
    - 프로세스 테이블의 항목과 PCB가 시스템에서 `완전히 제거`된 상태


### 프로세스 스케줄링과 컨텍스트 스위칭
- 프로세스 스케줄링 : 과거에 실행 단위는 프로세스
    - 스레드에게 공유자원을 제공하는 컨테이너로 역할이 바뀜

- 스레드 스케줄링 : 근래의 운영체제에서 실행단위는 스레드

- 현재는 프로세스 스케줄링과 스레드 스케줄링을 **모두 실시**한다.

## 3. 프로세스 계층 구조

### 프로세스 부모-자식 관계
    프로세스는 일반적으로 부모-자식 관계를 가진다.

- **#0 프로세스**는 시스템 부팅 시 실행되는 최초의 프로세스, **조상 프로세스**
    - 모든 프로세스는 **부모 프로세스**가 있다.
    
    - 부모 프로세스는 **여러개의 자식 프로세스**를 가질 수 있다.

- 자식 프로세스 생성 : 시스템 호출을 통해서만 가능

- `#0`과 `#1` 프로세스 : idle / init
    - `#0` 프로세스 : 최고의 어른 프로세스
        
        - Unix : 부팅을 담당하고 `#1` 프로세스 생성함
        
        - Linux : idle 프로세스, 부팅 관여 없이 아무일도 하지 않고 루프, 우선순위가 가장 낮음
        - Windows : `System idle process`, 아무일도 하지 않고 루프를 도는 단순 프로세스
    - `#1` 프로세스 : init 프로세스
        - Linux : 부팅 후 생성되는 모든 사용자 프로세스의 조상


### 프로세스를 다루는 시스템 호출 (리눅스)
- **fork** : `자식 프로세스 생성`하는 시스템 호출
- **wait** : 부모가 `자식의 종료를 기다리고 확인`하는 시스템 호출

- **exit** : 현재 프로세스의 종료를 커널에 알리는 시스템 호출

|부모가 자식의 종료를 기다리는 경우|자식이 부모보다 먼저 종료한 경우|
|:--:|:--:|
|![alt text](./[현준]%20Image/19.png)|![alt text](./[현준]%20Image/18.png)|

- 프로세스가 종료될 때, 모든 메모리는 반환됨. 

    - Terminated 상태로 남아있음.

    - **PCB**와 **프로세스 테이블**의 항목은 제거되지 않음.

 <br>

⭐ 부모에서 `wait()`을 통해 자식의 종료를 확인 할 의무가 있음!!
    
    → 그렇지 않으면 자식은 Zombie 상태로 남아있다!

- **좀비 상태가 된 프로세스를 죽이는 방법!**

    - 쉘에서 부모 프로세스에게 `SIGCHLD` 신호 보내기

        - `kill -SIGCHLD 부모프로세스 PID`

        - `SIGCHLD` 핸들러가 `wait()` 호출하여 좀비 자식 제거함

    - 부모 프로세스 강제 종료
        - `kill -9 부모 프로세스 PID`
        
        - 좀비는 `init` 프로세스의 자식이 되고, `init`이 `wait()` 호출하여 좀비 프로세스 제거

<br>

### 고아 프로세스 : 부모가 먼저 종료한 자식 프로세스

- 커널은 자식 프로세스(고아)를  `init` 프로세스에게 입양

- OS따라 강종 시키기도함

<img src="./[현준]%20Image/20.png" width=500>

<bR>

### 여러 종류 프로세스
- 백그라운드 프로세스 : 터미널 사용자와의 대화가 없는 채 실행되는 프로세스
    - idle 상태로 잠을 자거나 디스크에 스왑된 상태의 프로세스
- 포그라운드 프로세스
    - 터미널 사용자의 입력을 독점하는 프로세스
- CPU 집중 프로세스
    - 대부분의 시간을 계산 중심의 일(CPU 작업)을 하느라 보내는 프로세스

- I/O 집중 프로세스 : 입출력 작업을 하느라 상대적으로 많은 시간을 보내는 프로세스
    - CPU보다 I/O 집중 프로세스를 우선적으로 처리함.

** 👉 CPU 집중 프로세스 보다 I/O 집중 프로세스를 우선적으로 처리한다.**

<br>

## 4. 프로세스 제어

### 프로세스 생성 과정

1. **PID 번호** 할당 
2. **PCB 구조체** 할당 
3. `프로세스 테이블`에서 새 항목 할당 
4. 프로세스 테이블 항목에 `PCB 연결`
5. 새 프로세스 위한 `메모리 공간 할당`
    - 코드 + 데이터 + 힙 + 스택

6. PCB에 프로세스 정보 기록 
7. PCB에 상태를 `ready`로 표시하고 준비 큐에 넣음

<br>

### `fork()` 로 자식 프로세스 생성
    
- 부모 프로세스의 모든 환경, 메모리, PCB 등을 복사
- 부모와 동일한 모양이지만, 독립된 주소 공간을 소유함

- 리턴값 
    - `부모`에게는 `자식 PID` 리턴 
    
    - `자식`에게는 `0`을 리턴

<br>

###  프로세스 종료 `exit()`와 종료 대기

- 프로세스 종료 : `exit()` → 시스템 호출

- **프로세스 종료 과정** 
    - 프로세스 모든 자원 반환 
    
    - PCB `Terminated` 
    - 자식 프로세스 init에 입양 
    - 부프로세스에게 `SIGCHLD` 신호 전송

- 종료 코드 → 0 ~ 255 사이의 1바이트 숫자

    - 개발자가 임의로 정해서 사용하여 종료 숫자를 정함