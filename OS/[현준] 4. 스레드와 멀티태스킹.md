# 4장 스레드와 멀티태스킹

## 1. 프로세스의 문제점

### 프로세스의 문제점
- 태스크의 정의 : job이라고도 하며 일의 단위

- 멀티태스킹 : 여러 태스크를 동시에 실행 시키거나, 한 프로그램 내에서 여러 태스크를 동시에 실행 시키는 기법, 다중 프로세스 기법을 사용했으나, 프로세스 기반으로는 많은 문제점이 발생함
- 문제점
    - 프로세스 생성의 큰 오버헤드 : 프로세스 생성이 너무 과정이 많고 오래걸림

    - 프로세스 컨텍스트 스위칭의 큰 오버헤드
        - 프로세스 사이 통신의 어려움 : 각각 독립된 메모리 공간, 커널을 통한 데이터 송수신
    - 프로세스 코드의 순차적인 실행으로 인한 오버헤드
    - 시스템 호출이 포함된 프로세스의 지나친 입출력 대기시간
    - 다중 CPU를 이용해도 하나의 CPU에서 동작
    - 동일한 프로그램 호출시 동일한 프로세스 이미지가 주기억장치에 복수개 생성

<br>

## 2. 스레드 개념
- 스레드 출현 목적 : 프로세스를 실행 단위로 하는 멀티태스킹의 문제점
    - 프로세스보다 크기 작고, 생성 및 소멸이 빠르고, 컨텍스트 스위칭이 빠르고, 통신 쉬움

- 프로세스 2대 특성
    - 자원 소유권 : 자신의 프로세스 이미지를 위한 물리적 주소 공간 → 프로세스(태스크)
    - 실행 스케줄링 개체 : 실행 흐름을 만들고 컨텍스트 스위칭이 가능함 → 스레드
- 단일 스레딩 : 하나의 프로세스에 하나의 스레드만 있는 구조
    - MS-DOS, 초기 UNIX,
- 멀티 스레딩 : 하나의 프로세스 내에서 여러개의 제어흐름의 실행을 지원하는 기능
    - JAVA 수행시간환경, 최신 버전 Unix, Windows, Solaris
- 멀티 스레드에서 프로세스 정의
    - 프로세스 : 자원 할당의 단위, 재진입 가능 구조
    - 스레드 : 스레드 제어블록, 실행 스택, 정적 저장소

![alt text](./[현준]%20Image/image-2.png)


### 다중 스레드 적용 예
- 하나의 프로그램을 동시에 복수개 실행해도, 하나의 프로세스 이미지로만 사용 가능
    
    <aside>
    💡 방법
    
    - 하나의 프로세스 이미지만을 주기억 장치에 생성
    
    - 해당 프로세스 내에 추가적인 새로운 스레드 생성
    - 스레드 단위의 단기 스케줄링
    - 공통의 프로세스 이미지의 정보를 이용해 자신의 프로그램을 개별적으로 실행
    - 자신만의 TCB에 정보를 저장
    </aside>
    
    - 한 프로세스에서 코드를 기능별로 스레드 구분
    
    <br>

    <aside>
    💡 방법
    
    1. 기능적으로 코드를 분리 (입력, 출력, 계산)해 스레드화
    2. 모든 스레드 준비큐 진입
    
    3. 스레드를 기본 단위로 단기 스케줄링
    4. 자신만의 TCB에 정보 저장함
    </aside>
    
    <br>

    <aside>
    💡 장점
    
    - 자기 일 만 하면 됨.
    
    - 한 스레드가 블록되어도 나머지 스레드들이 수행 가능
    - 스레드들이 각기 다른 CPU에서 실행 가능
    - **각각의 스레드들이 별로로 단기 스케줄링**
    </aside>

<br>

### 스레드 개념
- 스레드는 실행 단위 스케줄링 단위
    - 하나의 응용프로그램에 동시에 여러 스레드 작성 가능
        
    - 스레드는 운영체제에게 실행 단위, 스케줄링 단위
    - 코드 데이터 힙 스택을 가진 실체
    - TCB가 있음
    
### 프로세스는 스레드들의 컨테이너 : 컨테이너 역할, 자원 공유의 역할
    
![alt text](./[현준]%20Image/image-11.png)
    
- 프로세스는 자신에게 포함된 스레드들의 공유 공간 제공
    - 프로세스의 코드, 데이터, 힙을 공유 / 스택 공간을 나누어 사용함. → 통신 용이
        
    - 스레드가 실행할 작업은 함수로 작성 (함수 주소는 TCB에 저장)
- 운영체제는 TCB 리스트로 전체 스레드를 관리함 (스레드 스케줄)
<br>

### 스레드 장점
- 스레드 생성 시간이 짧음 → 프로세스의 기존 공간 사용
    
- 프로세스 종료 시간보다 스레드 종료 시간이 더 짧음
- 스레드들 사이의 교환/교체 시간이 짧음 → `커널 개입없이 서로 통신 가능`
- 연관된 수행단위의 집합으로 구현되어야 하면 스레드의 모음으로 구성하는 것이 훨씬 효율
- 멀티 CPU의 효율적 사용

<br>

### 멀티스레딩에서 병행성, 병렬성
- 병행성 : 2개 이상의 스레드가 시간을 쪼개어 실행
        
    ![alt text](./[현준]%20Image/image.png)
        
- 병렬성 : 2개 이상의 스레드가 다른 CPU에서 동시 실행
        
    ![alt text](./[현준]%20Image/image-3.png)
        
<br>

## 3. 스레드 주소 공간과 컨텍스트

### 스레드 주소 공간 : 실행 중에 사용하는 메모리 공간
- 스레드 사이의 공유공간 : 코드, 데이터, 힙
    
- 개별 스레드 사적 공간 : 스레드 스택, 스레드 로컬 스토리지

### 각 주소 공간에 대한 설명
- 코드 영역 : 다른 모든 함수 호출 가능
    
- 데이터 영역 : 스레드들의 통신 공간
    - 전역변수 호출 가능
    
    - 개별 스레드 로컬 스토리지 (힙 스택에 할당 될 수도 있음)
- 힙 영역
- 스택 영역 : 사용자 스택
- 커널 스택 영역

![alt text](./[현준]%20Image/image-4.png)

### 스레드 상태
- 준비 : 스레드가 스케줄 되기 기다리는 상태
    
- 실행 : CPU에 의해 실행 중인 상태
- 대기 : 입출력을 요청하거나 sleep() 같은 시스템 호출로 중단된 상태
- 종료 : 스레드가 종료한 상태

<br>

### 스레드 운용
- 스레드 생성
    - main 스레드 생성 / 시스템 호출이나 라이브러리 함수 호출하여 새 스레드 생성 가능
    
- 스레드 종료
    - 프로세스 종료 : 프로세스가 종료되면 모든 스레드 종료 → 좀비가 없음
    - 스레드 종료 `pthread_exit()` : 해당 스레드만 종료
- 스레드 조인 : 다른 스레드가 종료할때까지 대기
    
    ![alt text](./[현준]%20Image/image-5.png)
    
    - 스레드 양보 : `yield()`와 같이 스스로 실행을 중단하고 다른 스레드 스케줄하도록 요청

- 스레드 컨텍스트 (문맥)
    - 스레드가 현재 실행중인 일체의 상황 : `CPU 정보`와 `메모리 정보`로 구성됨 / 문맥 저장시 CPU 레지스터 값만으로 정의함
    
    - 스레드 컨텍스트 정보
        - PC 레지스터 : 실행중인 코드 주소
        - SP 레지스터 : 실행 중인 함수의 스택 주소
        
        - 상태 레지스터 : 현재 CPU의 상태
        - CPU에 기타 수십개의 레지스터 : 데이터 레지스터 등
    
    - 컨텍스트 스위칭 할 때 TCB에 저정함.

- TCB 스레드 제어 블록→ 커널 영역에 생성 커널에 의해 관리
    - 스레드 정보 / 컨텍스트 / 스케줄링 / 관리를 위한 포인터

- Ready Queue / Block Queue
    - 준비 큐 : TCB를 연결하는 링크드 리스트
    
    - 블록 큐 : 블록 상태에 있는 스레드들의 TCB를 연결하는 링크드 리스트

- 다중 블록 리스트 : 입출력 장치별로 블록 큐 만들어 searching의 시간을 줄임

![alt text](./[현준]%20Image/image-6.png)


- 스레드 컨텍스트 스위칭 : 실행 할 스레드 CPU에 TCB적재

- 스레드 스위칭이 이루어지는 위치 : 시스템 호출 , ISR 실행

<br>

### 스레드 스위칭이 발생하는 이유
- 스레드가 자발적으로 다른 스레드에게 양보 `yield()`
- 스레드가 시스템 호출을 실행하여 블록되는 경우

- 스레드 타임 슬라이스를 소진한 경우
- I/O 장치로 부터 인터럽트가 발생한 경우

<br>

### 스레드 스위칭 과정
- CPU 레지스터 저장 및 복귀 : 현재 실행중인 스레드를 TCB에 / 실행할 TCB를 CPU에 적재
- 커널 정보 수정 : 기존 TCB를 준비, 블락 리스트로 / 실행할 TCB는 준비 리스트에서 분리

<br>

### 컨텍스트 스위칭 오버헤드
- 컨텍스트 스위칭은 모두 CPU 작업이며 컨텍스트 스위칭 시간이 길거나, 잦으면 컴퓨터 처리율 낮음
- 동일한 프로세스 내 다른 스레드로 스위칭
- 다른 프로세스의 스레드로 스위칭하는 경우 (추가적인 메모리, 캐시 오버헤드)

<br>

## 4. 커널 레벨 스레드와 사용자 레벨 스레드

### 커널 레벨 스레드 : 커널에 의해 만들어지며, 커널에 의해 스케줄링 되는 스레드
- 개발 CPU에서 동시 수행 가능함.

- 동일 프로세스내의 스레드가 블록되어도 다른 스레드들은 수행가능
- 커널 루틴 자체도 멀티 스레등 가능
- **단점** : 스레드 전환시 커널이 호출되므로 커널 모드로의 전환에 의한 오버헤드
- 순수 커널 레벨 스레드 : 부팅할 때부터 커널 공간에서 실행되도록 작성된 특별한 KLT

![alt text](./[현준]%20Image/image-7.png)

<br>

### 사용자 레벨 스레드 : 사용자 공간에 만들어지며, 커널은 스레드의 존재를 모름, 커널은 프로세스 단위로 스케줄링함
    - 스레드 라이브러리 : 단기 스케줄러에 의해 프로세스가 선택되면, 이 라이브러리가 프로세스 내부의 스레드들을 스케줄링 할 수 있다.
        - 커널은 프로세스 단위로만 스케줄링
        - 스레드 라이브러리 내부의 스케줄러를 이용해 스케줄링
    
    <aside>
    💡 장점
    
    - 동일 프로세스 내의 스레드 교환시 **커널 모드 권한** 불필요
        - 2번의 모드 변환 오버헤드 절약
    - 운영체제 스케줄러와 무관하게 **특정 응용에 적합한 스레드 스케줄링의 적용 가능**
    - 커널과 무관한 스레드 라이브러리 사용하므로 **모든 OS 사용가능**
    </aside>
    
    <aside>
    💡 단점
    
    - 스레드가 블록 상태가 되면 → 해당 프로세스 자체 블록 상태
    - 자켓팅 기술 : 프로세스 블록을 방지하는 기술 (라이브러리에 있음)
    - 다중 CPU의 장점을 못살
    </aside>
    

![alt text](./[현준]%20Image/image-8.png)

- ULT와 KLT의 비교

![alt text](./[현준]%20Image/image-9.png)
<br>

### 5. 멀티스레드 구현

- 사용자 레벨 스레드가 스케줄되고 실행되도록 구현하는 방법

<aside>
💡 방법 : ULT를 KLT로 매핑 시키는 방법 (ULT:KLT)


- N:1 매핑 → 순수 사용자 레벨 스레드 (단일 스레드 프로세스)
    - 장점 : 단일 코어 CPU에서 속도가 전반적으로 빠름
    
    - 단점 : 멀티 코어 CPU가 보편화된 지금 컴퓨터에서 비효울적
        - 하나의 ULT가 블록되면 프로세스 전체 블록

- 1:1 매핑 → 순수 커널 레벨 스레드 기법
    - 장점 : 개념 단순 구현 용이, 멀티 코어 CPU에서 높은 병렬성 제공, 하나 블록되어도 전체 블록되지 않음
    
    - 단점 : 모드 전환시 커널을 거쳐서 이동함, 커널에게는 부담

- N:M 매핑
    - 장점 : 커널의 부담이 적음
    
    - 단점 : 구현하기 복잡함, 거의 사용
</aside>

### 6. 멀티스레딩에 관한 이슈

- 프로세스와 스레드 리뷰
    - 프로세스는 스레들의 공간 → 자원의 컨테이너
    
    - 프로세스는 운영체제가 프로그램을 적재하는 단위, 스레드는 실행 단위
    - PCB : 환경 컨텍스트 / TCB : 실행 컨텍스트
    - 동일 프로세스에 속한 스레드 스위칭 속도가 빠름

### 7. 스레드 프로그래밍 기법

- 스레드 프로그래밍 기법 : Pthread, JAVA thread, Window thread 프로그래머 API 이용해 직접

- 암묵적 스레딩 → 자동적으로 생성해줌 : OpenMp, Grand Central Dispatch
- 멀티코어 상에서 소프트웨어 성능
    - 암달의 법칙 → 병렬화 할 수 없는 부분을 줄이기
    
    ![alt text](./[현준]%20Image/image-10.png)
    
    - 사실 멀티프로세서에서 오버헤드를 고려하면 속도 향상이 이론보다 줄어듬