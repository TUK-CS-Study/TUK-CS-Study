# 5장 CPU 스케줄링

## 1. CPU 스케줄링 개요
### 운영체제에서 일어나는 다양한 스케줄링

- **장기** 스케줄링 : **배치시스템**에서 대기중인 배치 작업 중 메모리에 적재할 작업 결정

- **중기** 스케줄링 : **Swapping** (주 기억 장치의 용량이 부족할 경우, 프로세스 이미지를 보조기억장치로 옮기거나 다시 불러오는 스케줄링)

- **단기** 스케줄링 : 프로세스/스레드 중 하나를 선택하여 CPU에게 할당, 요즘엔 스레드 스케줄링

- **입출력** 스케줄링 : 특정 입출력 장치에 대한 복수 개의 입출력 요청 중 하나를 선택함

<br>

### 다중 프로그래밍과 스케줄링
- CPU **Idle 시간 줄여**, CPU 활용률 향상 목적

- **다양한 스케줄링 기법들**

    - 작업 스케줄링 : 프로세스가 시작 또는 종료할 때마다 (**장기**)

    - CPU 스케줄링 : 메모리에 적재된 작업 중 CPU에 실행시킬 프로세스 선택 (**단기**)

    - 중기 스케줄링 : 스와핑 (주 기억 장치의 프로세스 이미지를 보조기억 장치로 옮겨 메모리 확보)

        - **스왑 아웃** : 주 기억 장치 → 보조 기억 장치

        - **스왑 인** : 보조 기억 장치 → 주 기억 장치

        💡 **이때 보류 상태라고도 불린다**

    <br>
    
    💡 **장기, 중기, 단기**의 의미는 스케줄러가 불려지는 빈도에 따라 부여되었다.        
    - **장기** → 가끔 한번씩
    
    - **단기** → 매우 자주 실행

<br>

### CPU burst와 I/O burst

- **CPU burst** : 프로그램 실행 중 **CPU 연산이 연속적으로 실행**되는 상황
![alt text](./[현준]%20Image/image-12.png)

- **I/O burst** : 프로그램 실행 중 **I/O 장치의 입출력이 자주 요청**되는 상황
![alt text](./[현준]%20Image/image-13.png)

<br>

### CPU 스케줄링 
- 실행 준비 상태의 스레드 중 하나를 선택하는 과정

- **CPU 활용률 향상**을 목표로 스케줄링

- **CPU 스케줄링 기준**
    
    - **우선순위가 높은 스레드**를 먼저 처리 
    - 모든 사용자에게 **균등한 시간을 배분**

    - 모든 스레드를 **완료시간 이내에 실행**시키는 목표를 갖는 시스템

    - 사용자에게 **빠른 응답**을 주는데 목표가 있는 시스템


    ![alt text](./[현준]%20Image/image-14.png)

<br>

### 스케줄링 알고리즘의 다양한 평가 기준

- CPU 활용률

- 처리율 : 단위 시간 당 처리하는 스레드 개수

- 공평성 : CPU를 **스레드들에게 공평하게 배분**

- 응답시간 : 대화식 시스템의 경우, 사용자의 요청에 대한 결과를 응답하는 시간

- 대기시간 : 스레드가 **준비 큐**에서 머무르는 총 시간

- 소요시간 : 스레드가 생성된 후 완료될 때까지 걸린 시간 → 사용자 입장

- 시스템 정책 우선 : 컴퓨터 시스템의 특별한 목적을 달성하기 위한 스케줄링 → 운영체제 입장

- 자원 활용률

<br>

### CPU 스케줄링과 타임 슬라이스
- **타임 슬라이스**

    - 시간을 잘게 쪼개어 사용, 시간 할당량이라고도 함

    - 스케줄 된 스레드에게 동작을 보장하는 CPU 시간

- **커널이 스레드를 타임 슬라이스 실행시키는 절차**
    - 커널이 스레드를 선택

    - 커널은 선택된 스레드의 **타임 슬라이스 값**을 **타이머 모듈**에 설정

    - 커널은 문맥 교환을 통해 **스레드를 실행**

    - **타이머 인터럽트가 발생하여 커널을 호출**

    - 커널은 실행중이던 **스레드를 강제 중단 후 준비 리스트에 삽입**

<br>

## 2. CPU 스케줄링 기본

### CPU 스케줄링이 실행되는 4가지 상황

- 스레드의 타임 슬라이스가 소진되어 **타이머 인터럽트** 발생

- 스레드가 자발적으로 **CPU를 반환** → `yield()` System Call

- 스레드가 **I/O를 요청**하여 **Block**될 때

- 더 높은 순위의 다른 스레드가 요청한 입출력 작업 완료로 인터럽트가 발생할 때

### CPU 스케줄링과 디스패치
>CPU 스케줄링 작업은 스케줄러와 디스패처 코드로 구성되어 동작

> 스케줄러 코드가 **실행할 스레드를 선택**하고, 디스패처 코드가 **스레드를 실제로 실행**
- **CPU 스케줄링 코드**
    
    - **스케줄러**라고 줄려서 부름 

    - 실행할 스레드를 **선택하는 기능**

    - 커널 코드의 일부로서 **호출을 통해서만 실행이 가능한 함수 형태**이며, 독립적으로 실행되는 프로세스나 스레드가 아님

    - **System Call**이나, **인터럽트 서비스 루틴**이 끝나는 마지막 단계에서 스케줄링 코드가 호출됨

<br>

- **디스패처 코드**

    - 스케줄러에 의해 선택된 스레드를 **CPU가 실행하도록 하는 작업**

    - 스레드 **컨텍스트 스위칭을 실행**하는 코드

    - 커널 모드에서 사용자 모드로 전환

![alt text](./[현준]%20Image/image-15.png)

<br>

### 선점 스케줄링과 비선점 스케줄링

- **비선점 스케줄링**
    - 현재 실행중인 스레드를 강제로 중단시키지 않는 방식

    - 예외적으로 스케줄링 또는 선점 되는 시점
        - 자발적으로 CPU 양보할 때 또는 종료할 때
        
        - CPU를 더 이상 사용할 수 없게 된 경우 

- **선점 스케줄링**
    - 필요시에 현재 실행중인 스레드를 **강제로 중단**시키고 다른 스레드를 선택하는 방식

    - 새로운 스케줄링(선점 되는) 시점

        - 타임 슬라이스가 소진되어 타이머 인터럽트가 발생될 때

        - CPU를 더 이상 사용할 수 없게 된 경우 → `Block`, `Sleep`

        - 인터럽트나 시스템 호출 종료 시점에서, 더 높은 순위의 스레드가 준비 상태일 때

    | 비선점 스케줄링 | 선점 스케줄링 |
    | :--: | :--: |
    | ![alt text](./[현준]%20Image/image-16.png) | ![alt text](./[현준]%20Image/image-17.png) |

<br>

### 기아와 에이징
- 기아 : 스레드가 스케줄링에서 선택되지 못한 채, 오랫 동안 준비 리스트에 있는 상황
    - 우선순위가 더 높은 스레드가 계속 들어오는 경우

    - 짧은 스레드를 우선 실행하는 시스템에서, 자신보다 짧은 스레드가 계속 도착하는 경우

- 에이징 : 스레드가 준비 리스트에 머무르는 시간에 비례하여 스케줄링 순위를 높이는 기법


<br>

## 3. CPU 스케줄링 알고리즘
### 시간 계산 
- 평균 대기 시간 : 스레드 생성 부터, 실제 작업하기 전까지의 대기 평균 시간

- 평균 소요 시간(평균 반환 시간) : 스레드 생성 부터, 종료하기 전까지의 평균 시간

- Burst Time : 스레드가 실제로 실행하는 시간

### FCFS : 먼저 큐에 도착한 스레드를 먼저 스케줄링

- **비선점** 스케줄링
- 기아 발생하지 않음
- 처리율 낮음

- 호휘 효과 발생 : 긴 스레드가 CPU를 오래 사용하면, **늦게 도착한 짧은 스레드가 오래 대기**하는 현상

![alt text](./[현준]%20Image/image-18.png)

### SJF (Shortest Job First) : 최단 작업 우선 스케줄링

- 스레드가 도착할 때 실행 시간이 짧은 순으로 큐에 삽입하고, 큐의 맨 앞에 있는 스레드 선택

- **비선점** 스케줄링

- ✨ 실제로 스레드의 실행 시간을 예측하는 것은 어려워서 비현실적인 알고리즘임

- 기아 발생 가능 (긴 스레드는 실행 기회를 얻지 못할 수 있음)

![alt text](./[현준]%20Image/image-19.png)

### SRTF (Shortest Remaining Time First)

- 남은 실행 시간이 가장 짧은 스레드 선택

- **선점** 스케줄링 : 더 짧은 스레드가 도착하면 선점됨

- 기아 발생 가능 (긴 스레드는 실행 기회를 얻지 못할 수 있음)\

- ✨ 실제로 스레드의 실행 시간을 예측하는 것은 어려워서 비현실적인 알고리즘임

![alt text](./[현준]%20Image/image-20.png)

### RR (Round Robin)

- 공평한 실행 기회를 주기 위해, 큐에 대기중인 스레드들을 타임 슬라이스 주기로 돌아가면서 선택

- 타임 슬라이스를 소진하면 큐 끝으로 이동

- **선점** 스케줄링 : 시간이 남으면 뒤로 이동함

- 공평하고, 기아 없고, 구현이 쉬움

- 잦은 스케줄링으로 전체 스케줄링 오버헤드가 크다.

![alt text](./[현준]%20Image/image-21.png)
 >타임 슬라이스가 몇 ms 인지에 따라 스케줄링 횟수가 달라진다.

### Priority 스케줄링

- 우선순위에 따라 스레드를 실행시키기 위한 목적

- 가장 높은 순위의 스레드를 선택할 수 있다.

- **선점 / 비선점 스케줄링**
    - 선점 : 더 높은 순위의 스레드가 도착할 때 현재 스레드 강제 종료 후 스케줄링
    
    - 비선점 : 현재 실행 중인 스레드가 종료될 때 스케줄링

- 기아 발생 가능 → 에이징 기법으로 해결 가능


### MLQ 스케줄링

- 여러개의 큐에 우선순위를 할당함.

- 스레드가 도착 시 우선순위에 따라 해당 우선순위에 큐에 삽입. 다른 큐로 이동 불가

- 가장 높은 순위의 큐가 완전히 비게 되는 경우에만 그 다음 순위의 큐에서 스케줄링


- **비선점 / 선점 가능**

- 기아 발생 가능함 : 상단 우선 순위 큐가 비지 않으면 하위 큐에서 실행 불가함

![alt text](./[현준]%20Image/image-22.png)


### MLFQ 스케줄링

- 기아를 없애기 위해, 여러 레벨의 큐 사이에 스레드의 이동이 가능하도록 설계

- 짧은 스레드와 I/O가 많은 스레드, 대화식 스레드의 우선 처리율

- n개의 고정 큐를 가지며, 큐마다 서로 다른 스케줄링 알고리즘 적용

- 큐마다 **스레드가 머무를 수 있는 타임 슬라이스**가 있고, 낮은 레벨의 큐 일수록 더 긴 타임 슬라이스 보장

- 현재의 큐에서 타임 슬라이스 종료되면, 하위 우선순위 큐로 이동됨


- 선점 스케줄링
- 기아 발생하지 않음, 큐에 대기가 길어지면, 더 높은 레벨의 큐로 이동 시킴

![alt text](./[현준]%20Image/image-23.png)


## 4. 멀티 코어 CPU에서의 스케줄링

![alt text](./[현준]%20Image/image-24.png)

- 멀티코어 시스템에서 싱글 코어 CPU 스케줄링을 사용할 때 2가지 문제점

    1. 컨텍스트 스위칭 후 오버헤드 문제 : 새로운 스레드의 코드와 데이터가 캐시에 채워지는 긴 시간

    2. 코어 별 부하 불균형 문제 : 스레드를 무작위로 코어에 할당하면, 코어마다 스레드 불균형 발생

<br>

- 컨텍스트 스위칭 후 오버헤드 문제 해결

    1. CPU 친화성 : 스레드를 동일한 코어에서만 실행하도록 스케줄링

    2. 코어 당 별도의 스레드 큐 사용 

<br>

- 코어 별 부하 불균형 문제 해결 : 부하 균등화 기법으로 해결

    1. 푸시 마이그레이션 기법 : 빈 큐를 가진 코어에 다른 큐의 스레드를 옮겨 놓음

    2. 풀 마이그래이션 기법 : 스레드가 없으면, 다른 코어의 스레드 큐에서 가져와 실행하는 기법