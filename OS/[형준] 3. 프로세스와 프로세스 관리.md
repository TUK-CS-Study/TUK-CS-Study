# 프로세스와 프로그램

## 프로그램
> 저장 매체에 저장되어 있는 **실행 가능한 파일**
## 프로세스
> 메모리에 적재되어 **실행 중인 프로그램**
- 프로세스 특징
	프로세스는 운영체제에 의해 관리된다.
	- 프로그램을 메모리에 적재하고 프로세스로 다룸
	- 프로세스에게 메모리 할당하고 코드와 데이터 등 적재
	- 각 프로세스들은 독립적인 메모리 공간 할당받아 사용
	- 운영체제는 각 프로세스의 메모리 위치와 크기 정보 관리
	- 프로세스마다 프로세스 ID 할당 받음
	- 커널이 프로세스의 모든 정보를 관리
	- 프로세스는 실행 - 대기 - 잠자기 - 대기 - 실행 - 정료 등의 생명 주기를 가짐(커널이 관리)

### 프로세스 관리
프로세스의 생성부터 종료까지 모든 생명 주기는 커널에서 이루어진다.
커널은 커널 영역에 프로세스 테이블(시스템에 한 개만 존재)을 만들고 이를 통해 프로세스 목록을 관리한다.
- 커널이 관리하는 내용
	- 생성, 실행, 일시 중단 및 재개, 정보 관리, 프로세스 통신, 프로세스 동기화, 프로세스 중단, 프로세스 컨텍스트 스위칭 등
### 프로그램 다중 인스턴스
> 한 프로그램을 여러 번 실행시키면 각 실행마다 독립된 프로세스가 생성되어 독립된 메모리 공간에 저장된다. 이러한 프로세스들을 다중 인스턴스라고 한다.

![{95871B84-F7FA-4C9D-94FD-5E0F1D32662B}](https://github.com/user-attachments/assets/060f50d3-2a52-4ab6-bdf7-98a8120fd6b9)
### 프로세스의 메모리 영역(프로세스 이미지) 
프로그램에서 프로세스로 변경되면 항상 사용자 공간에 4개의 구성 요소가 생성된다.
![{DF89170F-2C18-4080-BB06-7367BD75F908}](https://github.com/user-attachments/assets/f41550c4-4fd2-4aa4-a1ae-ddd2504da95a)
#### 코드 영역
> 실행될 프로그램 코드가 적재되는 영역
- 사용자가 작성한 함수 코드 및 라이브러리 함수 코드
#### 데이터 영역
> 프로그램에서 고정적으로 만든 변수 공간 
- 전역 변수 공간(정적 데이터 포함) 
#### 힙 영역
> 프로세스의 실행 도중에 동적으로 사용할 수 있도록 미리 할당한 공간
- mallock() 함수 등으로 할당 받는 공간 
- 힙 영역에서 아래 번지로 내려가면서 할당됨
#### 스택 영역 
> 함수가 실행될 때 사용될 임시로 사용되는 정보를 위한 할당 공간
- 지역 변수, 매개 변수, 함수 후 return할 주소 등
- 함수 호출 외에도 프로세스가 필요하면 사용할 수 있음
## 프로세스의 주소 공간( == 사용자 공간 + 커널 공간)
> 프로세스의 주소 공간은 가상 주소 공간을 의미한다.([2. 컴퓨터 시스템과 운영체제](https://github.com/TUK-CS-Study/TUK-CS-Study/blob/master/OS/%5B%ED%98%95%EC%A4%80%5D%202.%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md))

### 프로세스와 프로세스 주소 공간의 크기
프로세스의 크기와 프로세스 주소 공간의 크기는 다르다. 
- **프로세스 크기**
	- 적재된 코드 + 전역 변수 + 힙 영역에서 현재 할당 받은 동적 메모리 공간 + 스택 영역에 현재 저장된 데이터 크기
	- 힙 영역과 스택 영역은 크기가 가변적이기 때문에 프로세스의 크기는 실행하면서 계속 변화한다.
- **프로세스 주소 공간 크기**
	- CPU가 액세스할 수 있는 전체 크기
	- ex. 32bit CPU의 경우 4GB(2^32) 

### 프로세스의 사용자 공간과 커널 공간
![{6F3BAD68-65FE-4F78-8744-D9AD8B6B1328}](https://github.com/user-attachments/assets/088a3287-58d3-43db-9a60-e45d86acf132)
프로세스 주소 공간의 크기는 사용자 공간과 커널 공간의 합이다.
힙 영역과 스택 영역의 미할당 공간은 현재 프로세스 크기 계산에서 제외된다. 
각 프로세스는 독립적인 사용자 공간을 소유하고 하나의 커널 공간을 공유하여 필요할 때마다 커널 공간을 호출하여 사용한다.
#### 사용자 공간
> 프로세스의 4가지 영역에서 힙 영역과 스택 영역은 필요에 따라 사용되기 때문에 가변적이고 코드 영역과 데이터 영역은 프로세스를 처음 적재할 때 결정되어 불변적이다. 
#### 커널 공간
커널 코드, 커널 데이터, 커널 스택이 존재한다.

### 프로세스의 주소 공간(가상 주소 공간)에서 물리 메모리 공간으로의 매핑
프로세스의 주소 공간은 실제 메모리 주소 공간이 아닌 가장 주소 공간이고 실제 물리 메모리로의 매핑을 담당한다.
![{40BDA157-3F04-410C-B4B0-A8901B0259D4}](https://github.com/user-attachments/assets/8806ccf1-7179-44e3-9c4e-809cb145370c)
# 커널의 프로세스 관리
### 프로세스 테이블과 제어 블록(PCB)
- 프로세스 테이블
- 프로세스 제어 블록(PCB)
### 프로세스의 생명 주기
프로세스의 생성부터 종료까지 여러 상태로 바뀌면서 실행된다.
상태 정보는 PCB에 기록되고 상태가 변경될 때마다 운영체제에 의해 갱신된다. 
![{F8973EB0-23DB-4A9E-8614-58B9822F3CDC}](https://github.com/user-attachments/assets/bbaf8c8a-b2d5-4482-81e2-f9fdd5d5afc2)

- **New(생성 상태)**
	- 메모리 할당 및 필요 자원이 적재된 상태
	- 실행 준비를 마치면 준비 상태로 변경됨 
- **Ready(준비 상태)**
	- 바로 실행될 수 있는 상태이며 프로세스 스케줄링을 기다리고 있는 상태
	- 준비 큐에서 대기중이고 스케줄링 되면 실행 상태로 변경됨 
- **Running(실행 상태)**
	- CPU에 의해 실행중인 상태
	- 실행 중 CPU의 시간 할당량(타임 슬라이스)이 지나면 준비 상태로 변경되고 준비 큐에 삽입
	- 입출력 요청을 하면 커널은 프로세스를 블록 상태로 만들고 대기(블록)큐에 삽입
- **Blocked/Wait(블록/대기 상태)**
	- 프로세스가 자원 요청하거나 입출력 요청이 들어와서 완료를 기다리는 상태
	- 요청이 완료되면 준비 상태로 변경되고 준비 큐에 삽입
- **Terminated/Zombie 상태**
	- 프로세스가 남긴 코드(in PCB)를 부모 프로세스가 읽어가지 않아 불완전 종료된 상태
	- 프로세스가 할당 받은 메모리와 자원들 모두 커널에 의해 반환되었지만 프로세스 테이블 항목과 PCB는 여전이 시스템에 남아있는 상태
- **Terminated/Out 상태**
	- 부모 프로세스가 모든 종료 코드를 읽어가서 완전 종료된 상태(<->Terminated/Zombie 상태)
	- 프로세스 테이블 항목, PCB가 시스템에서 완전 제거된 상태

### 프로세스 스케줄링과 스레드 스케줄링
과거 운영체제에서 실행 단위는 프로세스였기 때문에 프로세스 스케줄링 방식을 사용했지만 근래의 운영체제에서 실행 단위는 스레드이기 때문에 스레드 단위로 스케줄링을 실시한다.
근래의 프로세스는 스레드들에게 공유 자원을 제공하는 컨테이너 역할이 되었다.

- 스레드 스케줄링
	- Ready 상태의 스레드 중 실행시킬 스레드 선택

# 프로세스의 계층 구조
모든 프로세스는 부모 프로세스로부터 생성되고 시스템 호출을 통해서만 프로세스 생성이 가능한다.(fork(), clone() 등의 커널 코드로 자식 프로세스 생성)
![{CF861AEC-9204-4BDB-BB6E-EE2BD6023052}](https://github.com/user-attachments/assets/987879b6-ed3d-45e6-b088-2eae8b8d2067)

### 프로세스 다루는 시스템 호출 함수
- fork()
- Wait()
- exit()

### 좀비 프로세스(종료 후 방치된 자식 프로세스)
> 프로세스를 종료했지만 부모 프로세스가 종료 코드를 읽지 않아 불완전 종료된 상태를 의미한다. 

부모 프로세스가 자식 프로세스의 종료 코드를 읽고 PCB를 제거해야 완전 종료가 된다.

- 프로세스 생성과 종료 과정
	1. fork()
		- 프로세스 생성
	2. exit()
		- 프로세스 종료하여 부모 프로세스에게 SIGCHLD 신호 전송
		- 할당된 모든 메모리 반환하지만 PCB와 프로세스 테이블 항목은 유지
	3. wait()
		- 자식 프로세스의 SIGCHLD를 받은 부모는 자식 프로세스의 종료 코드를 읽고 PCB와 프로세스 테이블 제거

### 고아 프로세스
> 부모 프로세스가 먼저 종료한 자식 프로세스를 의미한다.

- 부모 프로세스가 먼저 종료하는 경우
	- 프로세스가 exit()로 프로세스를 종료할 경우 커널은 자식 프로세스가 있는지 확인하여 있다면 자식 프로세스를 init 프로세스에 입양시킨다.
![Pasted image 20241007004318](https://github.com/user-attachments/assets/96ac856f-f4c4-45ef-811c-f00a4bcd2cd8)


### 기타 프로세스
- **백그라운드(background) 프로세스**
	터미널에서 실행되었지만, 사용자와 대화가 없는 채 실행되는 프로세스
	idle 상태로 잠을 자거나 디스크에 스왑된 상태의 프로세스
- **포그라운드(foreground) 프로세스**
	실행되는 동안 터미널 사용자의 입력을 독점하는 프로세스
- **CPU 집중 프로세스(CPU intensive process)**
	 대부분의 시간을 계산 중심의 일(CPU 작업)을 하느라 보내는 프로세스
	 CPU 성능에 따라 속도 좌우
- **I/O 집중 프로세스(CPU intensive process)**
	입출력 작업을 하느라 상대적으로 많은 시간을 보내는 프로세스
	입출력 장치나 입출력 시스템의 속도가 성능 좌우(I/O bound)

I/O 집중 프로세스가 CPU 집중 프로세스보다 스케줄링 우선순위가 높다. 
