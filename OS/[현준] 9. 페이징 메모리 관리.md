# 9장 페이징 메모리 관리

## 1. 페이징 메모리 관리 개요

### 페이징 개념

- **프로세스 논리주소 공간**을 0번지부터 동일한 크기의 **페이지**로 나눔
- 코드, 데이터, 스택 등 프로세스의 구성 요소에 상관 없이 0번지 부터 고정 크기의 페이지로 분할
- 모든 페이지에 0부터 순서대로 일련번호를 붙임 (**페이지 번호**)

<br>

- **물리 메모리** 역시 0부터 페이지 크기로 나누고, **프레임**이라고 부름
- 프레임을 페이지 프레임 또는 슬롯이라고도 부름
- 모든 프레임에 0부터 순서대로 일련번호를 붙임 (**프레임 번호**)

<br>

**[페이지 크기]**
- 주로 4KB (주소선 12개) 크기로 설정하나, 운영체제에 띠리 8KB,16KB 등으로 시스템의 특성에 맞게 설정

![alt text](./[현준]%20Image/image-54.png)

<br>

**[페이지 테이블]**
- 해당 프로세스의 각 페이지에 대해, 페이지 번호와 프레임 번호를 1:1로 저장하는 테이블
- 프로세스가 생길 때 프로세스마다 하나씩의 페이지 테이블이 커널 영역에 생성
- MMU는 페이지 테이블을 통해서 논리 주소를 물리 주소로 변환

![alt text](./[현준]%20Image/image-55.png)

<br>

### 페이징 기법

> 프로세스의 논리 주소 공간과 물리 메모리를 페이지 크기로 동일하게 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 분산 할당아혀 관리하는 기법 → 페이지 번호와 프레임 번호를 이용해 관리

- 프로세스마다 본인만의 **페이지 테이블**이 있음
- 논리 주소의 물리 주소 변환 → MMU에 의해
- 커널이 물리 메모리의 빈 프레임 리스트 관리 필요함

- 내부 단편화 발생 가능 (마지막 페이지에서 발생 가능)

<br>

### 페이징의 우수성 (세그멘테이션 대비)

- **구현 방법이 용이**
- 메모리를 0번지부터 **고정 크기**의 페이지 단위로 단순 분할하기 때문에 메모리 관리 방법이 쉽다.
- **높은 이식성**
- CPU에 의존적이지 않으므로 다양한 컴퓨터 시스템에 쉽게 이식 가능 → 인텔 CPU는 외부적으로 세그먼트 방식을 사용
- **높은 융통성**
- 시스템이나 응용에 따라 페이지 크기를 다르게 설정 가능
- **메모리 활용과 시간 오버헤드면에서 우수**
- 외부 단편화가 있을 수도 있다

- 현 개념에서는 부분 적재 개념이 없어서 외부 단편화의 가능성도 있다.

- 적재할 수 있는 프레임 수가 페이지 수의 합이 작으면 외부 단편화 발생 가능할 수 있다.

- 내부 단편화는 발생하지만 매우 작음 : 프로세스의 마지막 페이지에서만 발생

<br>

### 프로세스가 동적 할당 받을 때

![alt text](./[현준]%20Image/image-56.png)

`char *p = (char*) malloc(200);`

- 200바이트 할당 → 한 페이지에 4KB가 할당 됨
- 힙 영역의 페이지 5번 할당, 물리 프레임 2 할당
- `malloc(200)`은 논리 주소 20480을 리턴

`*p = 'a';`

- 프로세스 내에서 20480 번지에 `'a'`를 저장하는 코드
- 논리 주소 20480 MMU에 의해 물리 주소 8192 로 바뀌어, 물리 메모리 8192 번지에 `'a'` 저장

`free(p);`

- 20480 번지부터 200바이트 반환
- 반환 후 페이지 5 전체가 비게 되므로, 페이지 5와 프레임 2가 모두 반환

<br>

### 프로세스가 시스템 호출을 실행할 때

- 커널 공간의 페이지 k에 담긴 커널 코드 실행
- 커널 코드 역시 논리 주소로 되어 있음

<br>

## 2. 페이징의 주소 체계

### 페이징의 논리 주소

- **페이지 번호(p), 옵셋(offset)**
- 페이지 크기가 4KB라면, 페이지를 구성하는 내부 공간은 12비트 주소(A11 ~ A0)로 표현
- 옵셋 크기는 12비트
- 32비트 논리 주소 채계애서, 상위 20비트는 페이지 번호, 하위 12비튼 옵셋

<br>

🚨 **옵셋** : 프레임 내에서, 상대 주소로 상세 위치를 나타냄

![alt text](./[현준]%20Image/image-57.png)

<br>

### 논리 주소의 물리 주소 변환 개념

![alt text](./[현준]%20Image/image-58.png)

<br>

### 페이징 구현

- **하드웨어 지원**
- CPU의 지원

- CPU에 페이지 테이블이 있는 물리 메모리 주소를 가진 레지스터가 필요

- 운영체제에 의해 관리되며 MMU가 활용

- MMU 장치 : 논리 주소의 물리 주소 변환 장치이며 CPU 패키지에 내장됨
- **운영체제 지원**
- 물리 프레임의 동적 할당 / 반환

- 물리 메모리의 빈 프레임 리스트 생성, 관리 유지

- 프로세스의 생성 / 소멸에 따라 동적으로 프레임 할당 / 반환

- 페이지 테이블 관리 기능 구현

- 프로세스마다 페이지 테이블 생성, 관리 유지

- 페이지 테이블이 저장된 물리 메모리 주소를 PCB에 저장

- 프로세스 실행 시

- 페이지 테이블의 물리 메모리 주소를 CPU의 PTBR(Page Table Base Register)에 적재

<br>

## 3. 페이지 테이블의 문제점과 TLB

### 페이지 테이블의 문제점

- **[1번의 물리 메모리 액세스를 위해서 2번의 물리 메모리 맥세스가 필요]**
- 해당 페이지의 프레임 주소 정보를 가지고 있는 페이지 테이블은 물리 메모리에 저장되어 있음
- **페이지 테이블 항목 읽기** + **메모리 실제 데이터 액세스**

![alt text](./[현준]%20Image/image-59.png)

💡 TLB 사용으로 해결

<br>

**[페이지 테이블의 낭비]**
- 프로세스의 실제 크기는 매우 작기 때문에, 대부분의 페이지 테이블 항목이 비어 있는 문제
- 멀티 레벨 페이지 테이블 등의 방법으로 해결함

<br>

### TLB를 이용한 2번의 물리 메모리 액세스 문제 해결

TLB (Translation Look-aside Buffer) : 주소 변환 캐시로 불리며 MMU 내에 존재함

![alt text](./[현준]%20Image/image-60.png)

- 메모리에 있는 페이지 테이블을 읽어오는 시간을 없애거나 줄이는 기법

- [페이지 번호 p, 프레임 번호 f]를 항목으로 저장

- 페이지 번호로 전체 캐시를 동시에 고속 검색 → '연관 메모리' 라고 부름

<br>

### TLB를 활용한 메모리 액세스 과정
![alt text](./[현준]%20Image/image-61.png)

- 페이지 번호를 통해서, 프레임 번호를 알아내고

- 프레임 번호와 Offset을 조합하여 실제 물리 주소를 알아냄

**[캐시 Miss 발생]** : TLB에 페이지 번호와 프레임 번호가 없는 경우
1. CPU로부터 논리 주소 발생

2. 논리 주소의 페이지 번호가 TLB로 전달

3. 페이지 번호와 TLB 내의 모든 항목을 동시에 비교해서 TLB에 페이지 번호가 없는 경우 → **TLB miss**

4. 이 경우, MMU 메모리에 있는 페이지 번호와 프레임 번호를 가져와서 **TLB에 삽입**

5. **두번의 메모리 접근**

<br>

**[캐시 Hit]** : TLB에 페이지 번호와 프레임 번호가 있는 경우

1. CPU로부터 논리 주소 발생

2. 논리 주소의 페이지 번호가 TLB로 전달

3. 페이지 번호와 TLB 내의 모든 항목을 동시에 비교해서 TLB에 페이지 번호가 있는 경우 → **TLB hit**

4. **한 번의 메모리 접근**

<br>

### TLB로부터 얻는 교훈

**[TLB와 참조의 지역성]**
- TLB는 참조의 지역성으로 인해 효과적임

- **순차 메모리 액세스 시**에 실행 속도 빠름 → **TLB 히트가 계속 됨**

- TLB를 사용할 때, 랜덤 메모리 액세스를 하거나, 반복이 없는 경우 실행 속도가 느려질 수 있음


**[TLB 성능]**
- 페이지가 클수록 하나의 페이지의 많은 정보를 포함하므로 TLB 히트 증가

- 페이지가 클수록 내부 단편화 증가함 → **메모리 낭비**

- 페이지의 크기를 적절히 설정해야하지만, 현재는 페이지가 커지는 추세

**TLB reach**
- TLB의 성능을 나타내는 간단한 지표

- TLB가 채워졌을 때, TLB를 이용해 미스없이 작동하는 메모리 액세스 범위

<br>

### TLB를 고려한 컨텍스트 스위칭 과정 재정리
**[스레드가 동일한 프로세스 내의 다른 스레드로 스위칭 되는 경우]**

- TLB 항목들이 교체될 필요 없음 → 동일한 프로세스 테이블 사용

<br>

**[스레드가 다른 프로세스의 스레드로 스위칭 되는 경우]**

- CPU에 모든 레지스터를 TCB에 저장

- 새 프로세스의 PCB에 저장된 페이지 테이블 주소를 CPU의 Page Table Base Register에 저장

- TLB의 모든 항목 지우기 (이전 프로세스의 매핑 정보가 들어있기 때문)

- 새로 스케줄 된 스레드의 TCB에서 레지스터 값을 CPU에 적재함

<br>

## 4. 페이지 테이블의 낭비 문제 해결
### 페이지 테이블 낭비 문제의 해결책
1. 역 페이지 테이블
    
    ![alt text](./[현준]%20Image/image-62.png)

    - **실제 메모리의 프레임**을 기준으로 특정 프레임에 어떤 프로세스의 어떤 페이지가 할당되었는지롤 관리하는 방식

    - 시스템에 오직 **1개의 역 페이지 테이블**을 둠

    - 프레임 순서대로 프로세스 번호와 페이지 번호를 할당 함

            📌 프로세스 테이블은 프로세스 당 1개의 테이블을 가지는데, 
            역 페이지 테이블을 통해서 시스템 당 1개의 테이블로 전체적으로 관리할 수 있다.

    ⭐ **장점**
    [물리 메모리가 4GB일 때,]
    - 기존 페이지 테이블은 페이지 번호로 4바이트로 구성됨 → 4GB/4KB * 4바이트 = 4MB

    - 프로세스가 20개라면? → 4MB * 20개 = **80MB** 크기

    - 역 페이지 테이블 → 4GB/4KB * 8바이트 = **8MB**

<br><br>

2. 멀티 레벨 페이지 테이블
    
    ![alt text](./[현준]%20Image/image-63.png)
    
    - 프로세스가 **현재 사용 중인 페이지**들에 대해서만 페이지 테이블을 만드는 방식   

    - 여러 레벨로 구성함

    - 하나라도 페이지가 사용된다면, 1024개의 묶음으로 페이지 테이블을 메모리에 만듬

    - 프로세스 하나 당, 하나의 멀티 레벨 페이지 테이블이 생성 됨

    ![alt text](./[현준]%20Image/image-64.png)

    1024개의 페이지 묶음이 하나의 페이지 테이블에 할당되고, 1024개가 넘어간다면 새로운 페이지 테이블을 생성함

    ![alt text](./[현준]%20Image/image-65.png)

<br>

#### ⭐ **목적 : 페이지 테이블의 개수를 줄이기 위함!!**

| 기존 페이지 테이블 | 멀티 레벨 페이지 테이블 | 
| :--: | :--: |
| ![alt text](./[현준]%20Image/image-66.png) | ![alt text](./[현준]%20Image/image-67.png) |
| 사용의 개수와 상관 없이 페이지 테이블이 낭비 됨 | 사용 되는 페이지 개수의 묶음마다 페이지 테이블이 생성됨 |
| 기본 4GB | 1개의 페이지 디렉터리와 100개의 페이지 테이블이 필요하다면 4KB + 100 * 4KB = 404KB |

<br>

#### 단점 : 하지만 3번의 물리 메모리 접근이 필요함

페이지 디렉토리 → 페이지 테이블 → 실제 프레임