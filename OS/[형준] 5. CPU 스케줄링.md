# CPU 스케줄링이란?
> 실행 준비 상태(ready)의 스레드 중 하나의 스레드를 선택하는 과정

스케줄링은 여러 자원이 CPU를 사용하려고 경합할 때 적절하게 CPU 할당을 분배하기 위해 필요하다. 

### 시스템 내의 스케줄링 종류
- 작업 스케줄링(장기 스케줄링)
    배치 시스템에서 대기중인 배치 작업 중 메모리에 적재할 작업을 결정하는 스케줄링
    즉, 프로세스가 시작 or 종료할 때마다 실행되는 스케줄링이다.

- 스와핑 관련 스케줄링(중기 스케줄링)
    주기억장치(메모리)의 용량이 부족할 경우 우선순위가 낮은 프로세스 이미지를 보조기억장치로 옮기거나 다시 불러오는 스케줄링
    이렇게 옮겨진 프로세스를 보류 상태의 프로세스라고 한다.(가상 메모리 시스템과는 다른 방식)
    즉, 스왑 아웃과 스왑 인을 관리하는 스케줄러이다.
    - 스와핑 관련 용어
        - 스왑 아웃
            종료되지 않은 프로세스의 전체 프로세스 이미지를 주기억장치에서 스왑 공간으로 이동시키는 것
        - 스왑 인
            주기억장치에 여유 공간이 생겼을 때 스왑 아웃 된 프로세스 이미지를 주기억장치로 재적재하는 것

- CPU 스케줄링(단기 스케줄링)
    프로세스/스레드 중에 하나를 선택하여 CPU에 할당하는 스케줄링으로써 일반적으로 스케줄링이라 말하면 CPU 스케줄링을 말한다.
    즉, 메모리에 적재된 작업 중 CPU에 실행시킬 프로세스를 선택하는 스케줄링이다.

- 입출력 스케줄링
    여러 개의 입출력 요청 중 하나의 요청을 선택하는 스케줄링

![alt text](./[형준]%20Image/image-1.png)

### CPU burst와 I/O burst
프로그램은 CPU  연산 작업과 I/O 작업이 순차적으로 섞여 있는 실행 특정을 가지고 있다.
CPU-burst → I/O-burst → CPU-burst → I/O-burst의 반복 ...

- CPU-burst
    프로그램 실행 중 CPU 연산(일반 명령)이 연속적으로 실행되는 상황

- I/O-burst
    프로그램 실행 중 I/O 장치의 입출력이 자주 요청되는 상황

- CPU 집중 프로세스
    대부분의 명령이 CPU 연산으로 구성되는 프로그램
    I/O burst 시간이 CPU-burst 시간보다 많은 경우를 의미
    ![alt text](./[형준]%20Image/image-2.png)

- I/O(입출력) 집중 프로세스
    프로그램 실행 중  I/O 장치의 입출력이 비교적 자주 요청되는 프로그램
    CPU-burst 시간이 I/O burst 시간보다 많은 경우를 의미
    ![alt text](./[형준]%20Image/image-3.png)

스케줄링은 시스템 목표에 따라 우선순위가 달라질 수 있다.
    - 우선순위가 높은 스레드를 먼저 처리하는데 목표를 갖는 시스템
    - 모든 사용자에게 균등한 시간을 배분하는데 목표를 갖는 시스템
    - 스레드를 빨리 실행시키기 보다는 모든 스레드들을 완료시간(deadline) 이내에 실행시키는 목표를 갖는 시스템
    등이 있고 일반적인 스케줄링의 우선 순위는 다음과 같다.
    ![alt text](./[형준]%20Image/image.png)


### 스케줄링 알고리즘의 평가 기준
- CPU 활용률 - 운영체제 입장
    전체 시간 중 CPU의 사용 시간 비율

- 처리율 - 운영체제 입장
    단위 시간당 처리하는 스레드 개수

- 공평성 - 사용자 입장
    CPU를 스레드들에게 공평하게 배분 
    무한정 대기하는 기아 스레드가 생기지 않게 하기 위한 스케줄

- 응답시간 - 사용자 입장
    대화식 시스템의 경우에 사용자의 요청에 대한 결과를 응답하는 시간

- 대기시간 - 운영체제와 사용자 입장
    스레드가 준비 큐에서 머무르는 총 시간

- 소요 시간(반환시간) - 사용자 입장
    프로세스(스레드)가 컴퓨터 시스템에 도착한 후(혹은 생성된 후) 완료될 때까지 걸린 시간 

- 시스템 정책 - 운영체제 입장
    컴퓨터 시스템의 특별한 목적을 달성하기 위한 스케줄링

- 자원 활용률

### 타임 슬라이스
하나의 스레드가 너무 오랫동안 CPU를 독점할 경우 다른 프로세스를 오랫동안 사용하지 못하는 문제가 생길 수 있다.
이러한 경우를 방지하기 스케줄 된 스레드들이 CPU를 사용할 수 있도록 시간을 잘게 쪼개어 사용할 수 있도록 하는 타임 슬라이스 방식을 사용한다.(스레드들의 동작을 보장하는 CPU 시간)

타임 슬라이스의 시간을 모두 소비하는 것을 **타임 아웃**이라 한다. 

- 커널이 스레드를 타임 슬라이스 동안 실행시키는 절차
    1. 실행시킬 스레드 선택
    2. 스레드의 타임 슬라이스 값을 타이머 모듈(하드웨어)에 설정
    3. 문맥 교환을 통해 스레드 실행
    4. 설명 시간 이후 타이머 인터럽트 발생하여 커널 호출
    5. 스레드 강제 중단하고 준비 리스트(큐)에 삽입
    6. 1부터 다시 반복

### CPU 스케줄링이 실행되는 4가지 상황

- 타임 슬라이스 소진되어 타이머 인터럽트 발생
- 스레드가 자발적으로 CPU  반환
	yield() 시스템 호출 등을 통해 스레드가 자발적으로 CPU 반환

- 스레드가 I/O 요청하여 블록
- 더 높은 순위의 다른 스레드가 요청한 입출력 작업 완료로 인터럽트 발생

### CPU 스케줄링과 디스패치(dispatch)
스케줄러가 실행할 스레드를 선택하면 디스패처 코드가 스레드를 실행하는 방식이다.
아래 자세한 설명을 보자
##### CPU 스케줄링 코드(스케줄러)
- 실행할 스레드를 선택하는 기능
- 시스템 호출이나 인터럽트 서비스 루틴이 끝나는 마지막 단계에서 스케줄링 코드 호출
- 커널 모드에서 실행
##### 디스패처 코드(dispatcher)
- 스케줄러에 의해 선택된 스레드를 CPU가 실행하도록 하는 작업
- 실행이 종료된 스레드와 실행할 스케드와 관련한 컨텍스트 스위칭 실행하는 커널 코드
- 커널 모드에서 사용자 모드로 전환

![alt text](./[형준]%20Image/image-4.png)

### 선점 스케줄링과 비선점 스케줄링
실행중인 스레드의 강제 중단 여부에 따른 CPU 스케줄링 방식의 분류를 말한다.

##### 비선점 스케줄링
> 스레드가 CPU를 할당 받아 실행을 시작하면, 완료되거나 CPU를 더 이상 사용할 수 없는 상황이 될 때까지 스레드를 강제로 중단시키지 않고 스케줄링도 하지 않는 방식

- 예외적으로 스케줄링되거나 선점되는 방식
	- 자발적으로 CPU 양보하거나 종료할 때
	- CPU를 더 이상 사용할 수 없게 된 경우
		- I/O 요청으로 인한 블록
		- sleep 등 
##### 선점 스케줄링
> 필요시에 현재 실행중인 스레드를 강제로 중단시키고 다른 스레드를 선택하는 방식

- 새로운 스케줄링(선점) 되는 시점
	- 타임 슬라이스 소진되어 타이머 인터럽트 발생될 때
	- CPU 더이상 사용할 수 없게 된 경우
		- I/O 요청으로 인한 블록
		- sleep 등 
	- 인터럽트나 시스템 호출 종료 시점에서, 더 높은 순위의 스레드가 준비 상태일 때

![alt text](./[형준]%20Image/image-7.png)


### 기아와 에이징
##### 기아
> 스레드가 스케줄링에서 선택되지 못한 채 오랜 동안 준비 리스트(큐)에 있는 상황

- 기아가 발생하는 경우
	- 우선순위 기반 시스템에서, 더 높은 우선순위의 스레드가 계속 시스템에 들어오는 경우
	- 짧은 스레드 우선 실행시키는 시스템에서, 더 짧은 스레드가 계속 시스템에 들어오는 경우

이러한 기아가 발생하지 않도록 설계해야 하고 해결 방법 중 하나가 에이징이다.
##### 에이징
> 기아 문제의 해결책으로써 스레드가 준비 리스트(큐)에 머무르는 시간에 비례하여 스케줄링 순위를 높이는 기법

# CPU 스케줄링 알고리즘
## 비선점 방식 스케줄링 알고리즘
### FCFS(First Come First Served)
> 도착한 순서대로 처리

- 알고리즘: FIFO(선입선출)
- 문제점
	- **호위 효과**가 발생할 수 있다.
		- 한 스레드가 오랫동안 CPU를 사용하면 늦게 도착한 짧은 스레드가 오래 대기하는 문제

![alt text](./[형준]%20Image/{E2C53319-2ECE-4A1B-95C0-10FE4E091820}.png)

### SJF(Shortest Job First)
> 가장 짧은 스레드를 우선적으로 처리

- 알고리즘: 최단 작업 우선 스케줄링(SPN) 
- 실행 시간이 짧은 순으로 큐에 삽입하고, 큐의 맨 앞에 있는 스레드를 선택하여 실행
![alt text](./[형준]%20Image/{4EE11702-9A4F-4E72-9485-6BA461FF022B}.png)

- 문제점
	- **기아**가 발생할 수 있다.
		- 짧은 스레드가 계속 도착하면 긴 스레드들은 우선순위에서 밀리기 때문에 언제 실행될지 알 수 없는 문제
	- 스레드의 실행 시간을 아는 것은 불가능하기 때문에 사용하지 않는다.


## 선점 방식 스케줄링 알고리즘
### SRTF(Shortest Remaining Time First) 
> SJF의 선점 방식으로써 남은 시간이 짧은 스레드가 준비 큐에 들어오면 이 큐를 우선적으로 처리

- 알고리즘: 최소 잔여 시간 스케줄링
![alt text](./[형준]%20Image/image-6.png)

- 문제점
	- **기아**가 발생할 수 있다. 
	- SJF와 마찬가지로 스레드의 실행 시간을 아는 것은 불가능하기 때문에 사용하지 않는다.
### RR(Round-Robin)
> 큐에 대기중인 스레드들을 돌아가면서 타임 슬라이스만큼 실행

- 타임 슬라이스만큼 실행하고 타임 슬라이스를 소진하면 큐 끝으로 이동한다.
![alt text](./[형준]%20Image/{45F08E77-0001-4D9E-9D50-9240B9463498}.png)
![alt text](./[형준]%20Image/{A482BD9A-01AD-49CE-808F-6C1C9316436B}.png)

- 특징 및 장점
	- 타임 슬라이스가 크면 FCFS에 가깝고, 적으면 SJF/SRTF에 가깝다. 
	- 늦게 도착한 짧은 스레드는 FCFS보다 빨리 완료되고, 긴 스레드는 SJF(비선점)보다 빨리 완료된다. 
	- 모든 스레드가 공평하게 실행된다.
	- 기아 현상이 없다.
	- 구현이 쉽다.

- 문제점
	- 잦은 스케줄링으로 전체 스케줄링 오버헤드가 크고 특히 타임 슬라이스가 작을 때 더욱 크다. 
### MLFQ(Multilevel feedback queue)
> MLQ와 같은 방식이지만 서로 다른 레벨의 큐 사이에서 스레드 이동 가능 

- 알고리즘
	- 스레드가 도착하면 최상위 레벨 큐에 삽입한다.
	- 가장 높은 레벨 큐에서 스레드를 선택하고 큐가 비어 있으면 그 아래의 큐에서 스레드를 선택한다.
	- 만약 실행 중인 스레드가 큐에 할당된 타임 슬라이스를 초과하면 강제로 아래 큐로 이동시킨다.
	- 스레드가 자발적으로 중단한 경우 즉시 선점되고, 다시 시작시에는 현재 큐 끝에 삽입한다.
	- 스레드가 I/O로 실행이 중단된 경우 즉시 선점되고, I/O가 끝나면 동일 레벨 큐 끝에 삽입한다.
	- 큐에 있는 시간이 오래되면 기아를 막기 위해 하나 위 레벨 큐로 이동한다.
![alt text](./[형준]%20Image/{22A8473E-BD6C-4C23-BBBF-A3C673AEAD15}.png)
![alt text](./[형준]%20Image/{DA754773-E525-4FFE-B16D-1F8A3B256B53}.png)


- 특징
	- MLQ와 같은 방식이지만 다른 우선 순위 큐로 스레드 이동 가능하다.
	- 각 큐마다 스레드가 머물 수 있는 타임 슬라이스가 있고 타임 슬라이스가 종료되면 하위 우선순위 큐로 이동된다.
	- 낮은 레벨의 큐일수록 더 긴 타임 슬라이스를 보장한다.
	- MLQ와 다르게 **기아**가 발생하지 않는다.
		- MLQ에서 에이징 기법을 적용한 스케줄링이라 생각하면 된다. 



## 비선점/선점 모두 가능한 스케줄링 알고리즘

### Priority
> 우선 순위가 높은 순서대로 스레드 실행

- 특징
	- 높은 우선순위의 스레드일수록 대기 또는 응답 시간이 짧다. 
	- 스레드별 고정 우선순위를 갖는 실시간 시스템에서 주로 사용한다. 

- 문제점
	- **기아**가 발생할 수 있다.
		- 에이징 기법으로 해결할 수 있다.
### MLQ(Multilevel Queue)
> 우선순위가 할당된 여러 개의 큐에 스레드의 우선순위에 따라 스레드를 할당하고 우선 순위 순서대로 실행

- 알고리즘
	1. 고정된 n개의 큐에 우선순위를 할당한다.
	2. 스레드의 우선 순위에 따라 해당 우선 순위 큐에 스레드 삽입한다.(다른 큐로 이동 불가능)
	3. 높은 우선 순위 큐에 있는 스레드부터 실행하고 해당 큐가 완전히 비면 다음 우선 순위 큐에 있는 스레드를 실행한다.
![alt text](./[형준]%20Image/image-5.png)

- 특징
	- 고정 우선 순위를 갖는 시스템에서 사용한다.

- 문제점
	- **기아**가 발생할 수 있다. 



### Fair-Share
> 프로세스의 집합단위로 스케줄링하고 각 집합은 가중치가 부여되어서 가중치가 높은 집합에게 더 높은 우선 순위를 부여

# 멀티 코어 CPU에서의 스케줄링

![alt text](./[형준]%20Image/{3391F6E9-6BB6-465B-BC52-A0427BB122B4}.png)

### 멀티코어 시스템에서 싱글 코어 CPU 스케줄링을 사용한다면?
- 컨텍스트 스위칭 후 오버헤드 문제
	- 이전에 실행된 적이 없는 코어에 스레드가 배치된다면, **새로운 스레드이 코드와 데이터를 코어의 캐시에 추가하는데 긴 경과 시간**이 걸린다. 
- 코어 별 부하 불균형 문제
	- 스레드를 무작위로 코어에 할당한다면, **코어마다 처리할 스레드 수의 불균형이 발생**할 수 있다.

### 해결 방안
##### 컨텍스트 스위칭 후 오버헤드 문제 해결 방안
- CPU 친화성(코어 친화성) 적용
	- 스레드를 동일한 코어에서만 실행하도록 스케줄링하는 방식
- 코어 당 별도의 스레드 큐 사용
	![alt text](./[형준]%20Image/{58EE5E0E-C1AD-477B-8B62-0B40659EDF57}.png)
##### 코어별 부하 불균형 문제 해결 방안
- 푸시 마이그레이션 기법
	- 감시 스레드가 짧거나 빈 큐를 가진 코어에 다른 큐의 스레드를 옮겨옴
- 풀 마이그레이션 기법 
	- 처리할 스레드가 없다면 다른 코어의 큐에서 스레드 가져와 실행