# 2장 컴퓨터 시스템과 하드웨어

## 컴퓨터 시스템과 하드웨어


### 컴퓨터 시스템의 범위

#### 컴퓨터 시스템의 계층
1. 응용 프로그램 층

2. 운영체제 층

3. 컴퓨터 하드웨어 층
<br><br>

#### 컴퓨터 시스템의 계층 구조의 특징
- 하드웨어는 모두 **운영체제의 배타적 독점적 지배** 받음

- 사용자 또는 프로그램이 하드웨어에 대한 **직접 접근 불허** 

    → **반드시 운영체제를 통해서만 접근 가능**

    → **사용자가 하드웨어에 대해 몰라도 컴퓨터 사용 가능**
<br><br>

#### 컴퓨터 하드웨어 종류

- **CPU**
    
    컴퓨터의 핵심 장치, 프로그램 코드를 해석하여 실행하는 중앙 처리 장치
    
    **📌 CPU 구성 요소** : **ALU, 제어 장치, 레지스터**
    - ALU : 다양한 산술 및 논리 연산을 수행
    <br><br>
    ![alt text](./[현준]%20Image/3.png)
    **레지스터**를 통해 입력받은 **피연산자**로 계산하여 계산 결과는 **Flag Register**에 저장한다.
    <br><br>
    ![alt text](./[현준]%20Image/image-1.png)
    <br><br>
    - 제어 장치 : 시스템 전체의 효율적인 작동을 위해 전기적 제어 신호를 발생, 다른 컴퓨터 부품들을 제어
        
        1. Clock 신호를 받아들임
        
        2. 레지스터에서 **명령어**와, 플래그 레지스터에서 **플래그**를 받아들임
        
        3. 제어 버스로 전달된 제어 신호를 받아들임 → 다양한 장치에서 제어 신호가 옴

        4. 제어 신호를 다른 장치에 보낼 수 있다.
    <br><br>
    - 레지스터 : 프로그램 속 명령어와 데이터가 저장되는 공간
        
        1. **프로그램 카운터(Program Counter, PC)** 
        
            - **명령어의 주소**를 저장하는 레지스터, 다음 명령어의 위치를 가리킴

        2. **명령어 레지스터(Command Register, Instruction Register, IR)** 
        
            - 현재 CPU가 해석하고 있는 **명령어**를 저장하는 공간
            
            - 어떤 연산을 수행할지 결정하는데 중요한 역할


        3. **메모리 주소 레지스터(Memory Address Register, MAR)**

            - **메모리의 주소**를 기록하는 레지스터

            - 주소를 레지스터에 기록해두고, 메모리에 접근할 수 있음


        4. **메모리 버퍼 레지스터(Memory Buffer Register, MBR)**

            - 메모리와 주고 받을 **데이터**와 명령어를 저장하는 공간

            - 메모리에서 읽어온 데이터가 여기 저장되어 사용됨

            - 메모리에 데이터를 기록할 때도 여기에 저장됨

        5. **범용 레지스터(General Purpose Register)**
            - 다양한 목적으로 사용 되는 레지스터

            - 임시 데이터 저장소, 연산 결과 중간 결과 저장소

        6. **플래그 레지스터(Flag Register)**
            - 여러 플래그를 저장해두는 레지스터

        7. **스택 포인터 레지스터(Stack Pointer Register)**
            -  스택의 톱 메모리 주소 저장
    
    <br>    
    
    📌 **32비트 컴퓨터?**
        
        한 번에 32비트를 처리할 수 있는 내부 구조를 갖는 CPU 
    - 32개의 주소선이 있고, 2^32개 바이트, 4GB 넘어선 영역은 사용할 수 없음
    
    ![alt text](./[현준]%20Image/4.png)

    <br>    
    
    📌 **CPU 기계 명령**
        
    - CPU가 해석하고 실행할 수 있는 **2진수의 기계 명령**
    
    - 2진수인 기계어로 직접 프로그래밍 하기 어려워, 어셈블리어로 코딩할 수 있음  

    <br>    
    
    📌 **CPU의 명령 처리 과정**

    ![alt text](./[현준]%20Image/5.png)
    **< 메모리 100번지에 저장된 명령어를 실행 >**
    
    1. **프로그램 카운터 레지스터**에 **100**을 담아 주소 버스에 싣는다.

    2. 메모리 100번지에 있는 명령어를 가져와 데이터 버스에 싣는다.

    3. 가져온 데이터를 IR 레지스터에 저장하고 PC를 다음 번지로 수정한다.
        - 가져온 데이터 : `mov eax, [300]` (메모리 300번지의 값을 읽어 eax 레지스터에 저장)
    4. CPU는 300번지를 주소 버스에 싣는다.
    
    5. 메모리 300번지에 저장된 데이터를 **데이터 버스**에 싣는다.

    6. CPU는 **임시 데이터 레지스터**에 데이터를 저장한다
    
    7. 명령 실행 결과인 50을 **eax 레지스터** 저장한다.

<br><br>

- **메모리**

        CPU에 의해 실행되는 프로그램 코드와 데이터가 적재되는 공간

    - **스택**
       
        - 메모리의 일부를 스택으로 사용하도록 할당된 공간
        
        - Stack Pointer Register가 스택 꼭대기를 가리킴

        - **저장되는 내용**
            - 함수의 **지역 변수**들
            - 함수가 호출될 때 전달받은 **매개 변수** 값들

            - 함수가 실행된 후 **돌아갈 주소**
            - 함수가 의도적으로 **저장해 두기 위한 값**
    
    - ⭐ 컨텍스트 (문맥)

        - 한 프로그램이 실행 중인 일체의 상황 혹은 상황 정보 
        
        - 아래 값들을 하나로 문맥으로 관리함

            - **CPU**의 PC, SP, 기타 레지스터 값
            - **메모리**의 프로그램 코드와 데이터, 스택, 동적 할당을 받아 저장한 값
        
        **⭐ 컨텍스트 스위칭**
            
            CPU가 현재 프로그램의 실행 중지하고, 다른 프로그램을 실행할 때 발생

        - 컨텍스트에 프로그램의 마지막 상태가 저장됨 

            ![alt text](./[현준]%20Image/6.png)
        
        <br>

        - Context Switching 과정
            
            1. 현재 실행중인 프로그램의 컨텍스트를 메모리에 저장

            2. 새로 실행시킬 프로그램의 저장된 컨텍스트를 CPU에 복귀 
<br>
<br>

## 컴퓨터 시스템의 계층 구조와 운영체제 인터페이스
### 컴퓨터 시스템의 계층 구조
아래 4가지 구조가 계층으로 구성되어 있음
> 사용자 <br>
> 응용프로그램 <br>
> 운영체제 <br>
> 하드웨어

<br>

⭐ **계층 구조의 장점**

- **계층간 독립성 확보** ➜ 다른 계층의 상세 내용은 몰라도 사용 가능

- **사용자, 응용프로그램 / 운영체제 / 하드웨어** 의 구조로 되어 있어, 운영체제가 두 구간을 알아서 관리해주는 매개체가 됨

- 운영체제는 **자원에 대한 충돌 해결**, **성능 최적화**, **사용자의 시스템 사용 효율화**를 처리함

<br>

⭐ **운영체제와 응용프로그램 사이의 관계**
- 응용프로그램이 직접 하드웨어를 다루지 못하도록 차단
    - **System Call** 을 통해서 하드웨어를 호출함

- 응용프로램과 하드웨어 사이의 인터페이스
- 응용프로그램 실행 순서 제어
- 응용프로그램들 사이의 통신 중계

<br>

### ⭐ 운영체제의 전체 기능 정리
**4대 자원 관리** 및 기타 기능
1. 프로세스와 스레드 관리
2. 메모리 관리

3. 파일 관리 혹은 파일 시스템 관리
4. 장치 관리

---

5. 사용자 인터페이스

6. 네트워킹

7. 보호 및 보안

<br>

### ⭐ 운영체제 구성
- **커널** 
    - 운영체제의 핵심 부분
    - 부팅 후 메모리에 상주하는 코드와 데이터이며 운영체제의 핵심 기능 모두 구현
    
    - 커널 기능을 이용하려면 응용프로그램은 무조건 **System Call**을 사용한다
    
    - **커널의 종류**
            
            > 모놀리식 커널 : 단일 커널이라고 부르며, 커널의 모든 기능이 하나의 파일로 구현됨
            
            > 마이크로 커널 : 기본 핵심 기능만 커널에 구현하고, 나머지 기능은 서버라는 프로세스로 제공
               → 파일 시스템, 하드웨어 드라이버가 프로세스로 제공되어 커널의 메모리를 줄일 수 있음

            > 하이브리드 커널 : 두 가지 방식을 모두 혼합하여 사용, 현재는 하이브리드로 많이 사용
        <br>
            
    - **커널에 접근하는 2가지 방식**
            
            > 시스템 호출 : 응용 프로그램에서 커널을 호출하는 방식
                → 시스템 호출 라이브러리를 통해서 하드웨어를 호출함

            > 인터럽트 : 하드웨어에서 커널을 호출하는 방식
                → 장치들이 입출력 완료, 타이머 완료 등을 CPU에게 하드웨어 신호로 보냄

                → 인터럽트 서비스 루틴을 사용하여, 커널 영역에 적재하여 하드웨어 신호를 처리함
- 도구 소프트웨어와 GUI

    - 사용자가 컴퓨터를 편리하게 사용할 수 있도록 제공하는 Tool SW / Tool 운영프로그램

- 디바이스 드라이버
    - 장치를 직접 제어하고 입출력을 담당하는 소프트웨어
    
    - 예) 키보드 드라이버, 디스크 드라이버, 그래픽 드라이버 ...
<br>
<br>

## 커널과 시스템 호출
### 사용자 공간과 커널 공간
- 사용자 공간 : **응용프로그램이 적대**되고, 동적으로 할당 받는 공간

    - **사용자 공간 크기** : 프로그램 코드 + 데이터(전역 변수) + 힙 (동적 할당) + 스택 
        ![alt text](./[현준]%20Image/7.png)

    - 크기는 정해져 있기 때문에, 한 응용프로그램이 더 크게 사용할 수 없음
- 커널 공간 : 커널 코드, 커널 데이터 등 커널에 의해 배타적으로 사용되는 공간

- 가상 주소 공간 : 사용자 공간 + 커널 공간
    - 📢 사용자 공간이 2GB라고 하고, 커널 공간이 2GB라고 하자. 
    
    - 이럴 때, 응용프로그램 마다 사용할 수 있는 메모리는 4GB이다.

    - 하지만 물리 메모리가 4GB보다 작으면 어떻게 해야 할까?

    ![alt text](./[현준]%20Image/8.png)


    이럴 때 방법이 있다.

    하드 디스크의 일부를 메모리로 사용하고, 그 일부만 실제 메모리에 적재하는 방법이다.
    
    바로 **가상 메모리** 기법과 **부분 적재** 방법이다. 추후 공부할 예정이지만 간단히 알아보자.

    - **가상 메모리** : 물리 메모리의 데이터를 하드 디스크에 저장하여 물리 메모리의 빈 영역을 확보
    
    - **부분 적재** : 프로그램의 일부분 만을 물리 메모리에 적재하고 실행
    
    ![alt text](./[현준]%20Image/9.png)

<br>

### 사용자 모드와 커널 모드
> 특정 시점에 CPU는 사용자 모드와 커널 모드 중에서 하나의 모드로만 실행
- 사용자 모드 

    - CPU의 모드 비트 = 1

    - 사용자 공간에 이는 코드나 데이터를 엑세스함

    - **특권 명령** 실행 불허 : 하드웨어나 시스템 관련 처리를 위해 설계된 특별한 명령

    - **특권 명령** : 입출력 장치로 부터, 입출력, 시스템 중단, 컨텍스트 스위칭, 인터럽트 금지 등 특별한 목적으로 설계된 CPU 명령

        - I/O 명령 : 입출력

        - Halt 명령 : CPU의 작동을 중지시키는 명령

        - 인터럽트 플래그를 켜고 끄는 명령

        - 타이머 설정 명령
        - 컨텍스트 스위칭 명령
        - 메모리 지우기 명령
        - 장치 상태 테이블 수정 등의 명령


- 커널 모드

    - CPU의 모드 비트 = 0

    - 특권 명령 사용 가능하며 모든 메모리 공간의 사용 가능

![alt text](./[현준]%20Image/10.png)

<br>

#### **커널**
- 커널은 부팅 시에 커널 공간에 적재된 함수들과 데이터 집합

- 커널 코드들은 함수들의 집합

![alt text](./[현준]%20Image/11.png)

<br>

#### **라이브러리**
모든 라이브러리는 **사용자 공간**에 위치한다.

- 표준 라이브러리 : `strcmp`, `printf` ..

- 시스템 호출 라이브러리 
    - 커널을 호출하기 위한 라이브러리
    
    - 시스템 호출 함수가 포함되어 있으며, 시스템 호출 함수를 `커널 API`라고 부른다.

    - **커널 공간이 호출되는 방식**
        
        **[사용자 공간]**
        - 사용자가 작성한 코드에서 커널 공간 호출 요청

        - 시스템 호출 라이브러리를 통해 시스템 호출 함수 (커널 API) 가 호출됨
        
        **[커널 공간]**
        - 시스템 호출을 핸들러를 통해서 커널 함수들을 실행함
        - 다시 사용자 공간으로 리턴해줌

    ![alt text](./[현준]%20Image/12.png)


<br>

#### 💡[탐구 1] `printf()`는 직접 디스플레이에 출력할까?

`printf`는 직접 출력할 수 없다!

출력 버퍼에 데이터를 작성하고 디스플레이에 출력하기 위해 `write()` 시스템 호출 함수를 호출

![alt text](./[현준]%20Image/13.png)

<br>

#### 💡[탐구 2] `fread()`와 `read()`의 비교

- `fread()`는 표준 라이브러리 함수
    - `read()`를 호출하여 라이브러리 내 버퍼를 한 번에 모두 채운다

    - 라이브러리 버퍼가 비거나 부족하면 다시 `read()`를 호출

- `read()`는 시스템 호출 함수

    - 시스템 호출을 이용하여 커널 코드 실행

    - 요청한 양 만큼만 읽어오기 때문에, `for`문으로 반복하면 여러번의 `System Call` 발생

**🤔 둘 중에 뭐가 더 빠를까??**

    → 시스템 호출 함수가 커널 내에서 동작하기에 조금 더 빠른가? 생각할 수도 있지만, 시스템 호출을 많이 할 수록 프로그램 속도가 느려진다. 
    
    라이브러리 함수는 컴파일러를 통해서 미리 읽어올 데이터의 양을 계산해서 한번에 읽어올 수 있는데, 시스템 호출 함수는 호출 할때마다, 시스템 호출을 하기 때문에 커널 공간에 갔다가 사용자 공간으로 돌아오는 시간이 걸린다.


#### 시스템 호출에 따른 비용 정리

시스템 호출을 하는데 걸리는 시간을 정리해보자.

- 시스템 호출 함수에 저장할 데이터들을 CPU 레지스터에 저장
- 사용자 모드에서 커널 모드로 전환

- System Call Handler 실행

- CPU 내 레지스터가 훼손되는 것을 막기 위해 스택에 저장

- 시스템 호출 표에서 시스템 호출 함수 찾기

- 시스템 호출 함수 실행
- 스택에 저장해둔 레지스터 복귀
- 사용자 모드로 복귀