# 10장 가상 메모리

## 1. 물리 메모리의 한계
> ❗ **컴퓨터에 설치 가능한 물리 메모리의 한계**

- 32비트 CPU는 주소선이 32개이고, 물리 메모리의 최대량 **4GB**

- 64비트 컴퓨터에서는 **8GB ~ 32GB**

<br>

📢 물리 메모리 용량이 프로세스의 합보다 작으면 어떻게 할까?

<br>

## 2. 가상 메모리 개념

### 가상 메모리의 개요
- 설치된 물리 메모리의 크기 한계를 극복하는 해결책

<br>

### 가상 메모리 기법의 핵심 2가지

- **물리 메모리를 디스크 공간으로 확장**
    
    - 프로세스를 물리 메모리와 디스크에 나누어 저장

- **Swapping**

    - 물리 메모리가 부족할 때, 실행에 필요하지 않은 부분은 디스크로 이동

    - 프로세스 실행 시 **실행에 필요한 코드나 데이터에 일부**만 물리 메모리에 적재
    - 디스크 스왑 전용 영역 → 접근 속도가 다른 파일들과는 다르게 매우 빠름


<br>

### Unix, Linux 등에서 사용하는 전통적인 가상 페이징 시스템의 구현 방법
- 가상 페이징 방식 사용

- 처음에 프로세스의 전체 논리 주소 공간을 **모두 디스크(스왑 영역)에 일괄적으로 생성**

- 필요하면 물리 메모리에 적재하고, 아니면 스왑 영역의 내용을 갱신함

![alt text](./[현준]%20Image/image-68.png)

<br>

### Window에서 사용하는 가상 페이징 시스템의 방식

- 처음 시작할 때 만들지 않고, 새로운 페이지가 **필요할 때마다** 보조 기억장치에서 필요한 페이지만 복사해서 물리 메모리에 적재해 사용함

- 추후 Swapping이 필요한 경우, 스왑 영역에 저장함

![alt text](./[현준]%20Image/image-69.png)

| Unix, Linux | Window |
| :--: | :--: |
| ![alt text](./[현준]%20Image/image-70.png) |![alt text](./[현준]%20Image/image-71.png) |
| 모든 논리 주소를 HDD에 저장해두고, <br>필요할 때마다 Swapping 해서 사용함 | 스왑 아웃한 페이지만 HDD에 전달 | 
<br>

### 가상 메모리 구현

1. 요구 페이징 : 페이징 + 스와핑

2. 요구 세그먼테이션 : 세그먼테이션 + 세그먼트 스와핑

<br>

### 가상 메모리 기법에 대한 문제들

- 스래싱 문제 : 물리 메모리와 디스크의 스왑 영역 사이에 입출력이 너무 빈번히 발생하지 않는지?

- 페이지 테이블 : 페이지 테이블은 어떻게 구성?

- 페이지 폴트 : 가상 주소를 물리 주소로 변환할 때 페이지가 프레임에 없는 경우?

- 페이지 할당 : 어떤 페이지를 물리 메모리에 두고 디스크에 둘지?

- 스왑 영역 : 디스크의 스왑 영역 크기는 얼마나 적당한지?

- 작업 집합 : 프로세스는 일정 시간 범위에서 실행 중에 몇 개의 프레임을 실제로 사용하는지?

- 페이지 교체 알고리즘 : RAM에 어떤 프레임을 비워야 하는지? 

- 쓰기 시 복사 : 자식 프로세스의 메모리 공간은 어떻게 되는지?

<br>

## 3. 요구 페이징

### 요구 페이징 개념

![alt text](./[현준]%20Image/image-72.png)

> 💡 실행에 필요한 일부 페이지만 메모리에 적재하고, <br>나머지는 디스크에 두어 페이지가 필요할 때만 메모리에 적재하는 방식

- 프로세스의 페이지가 있는 디스크 영역

    - 스왑 영역 : 프레임이 부족할 때 저장되는 디스크 공간

    - 실행 파일 : 일반 디렉토리 공간에 있는 프로세스용 프로그램

- 스왑 영역

    - 메모리가 부족할 때, 메모리를 비우고 페이지를 저장해두는 디스크의 영역

    - 리눅스 : 디스크 내 특별한 위치 혹은 스왑 파티션에 구성

    - Window : C:/pagefile.sys 파일을 스왑 영역으로 사용함

- 페이지 테이블 항목

    - `present / vaild bit` (유효 비트) : 요구되는 페이지가 물리 메모리에 있는지 여부
        - 1 : 메모리에 있음

        - 0 : 디스크에 있음

    - `modified / dirty bit` (변경 비트) : 페이지가 적재된 후, 수정되었는지 여부
        - 1 : 페이지가 적재된 이후 수정됨, 나중에 저장될 필요가 있음 

        - 0 : 페이지가 수정된 적이 없음, 스왑 영역에 저장될 필요 없음


    - `physical address` (프레임 주소)
        - 1 : 페이지가 적재되어있는 프레임 주소

        - 0 : 페이지가 있는 디스크 블록 번호

    - [Unix만 존재] `Disk address` (디스크 주소) : 모든 페이지가 디스크에 존재하기 때문에 디스크 주소도 있음

    
- 페이지 폴트 : 페이지가 물리 메모리에 없을 때, **페이지 폴트가 발생**

    ![alt text](./[현준]%20Image/image-73.png)
    
    - 스왑-인 : 페이지를 스왑 영역 → 프레임에 저장

    - 스왑-아웃 : 페이지를 프레임 → 스왑 영역에 저장하고, 프레임을 비우는 행위

<br>

### 요구 페이징 실행 순서

![alt text](./[현준]%20Image/image-74.png)

<br>

1. **프로세스의 시작 페이지 적재**

    ![alt text](./[현준]%20Image/image-75.png)

<br>

2. **페이지 폴트 발생, 실행 파일로부터 페이지 적재**

    ![alt text](./[현준]%20Image/image-76.png)

<br>

3. **메모리가 부족하면 스왑-아웃 / 스왑-인**

    ![alt text](./[현준]%20Image/image-77.png)

<br>

4. **스왑 아웃된 페이지 100을 스왑 인, 그리고 n++ 실행**

    ![alt text](./[현준]%20Image/image-78.png)


<br>

### 가상 메모리의 실용성

- **쓰레싱** : 시스템이 프로세스 수행보다 블록 교체에 대부분의 시간을 소비하게 되는 현상 방지해야함


- 프로세스의 **성긴(비어있는)** 주소공간 활용

    - 스택은 위에서 아래로, 힙은 아래에서 위로 할당

    - 가상 메모리에서 공백은 실제 메모리가 할당되지 않음

- 공유 라이브러리
    - 라이브버리를 여러 프로세스가 공유함

    - `fork()`시 자식 프로세스의 빠른 생성이 가능함 → 페이지들을 공유
        

- 쓰기 시 복사
    - 초기에는 부모, 자식 프로세스가 페이지들을 공유

    - 공유된 페이지의 내용을 변경시에만 해당 페이지를 복사하여 새로운 페이지를 만들고,
     
        자식 프로세스의 페이지 테이블을 갱신함

    📢 **완전 복사의 비효율성** 
        ![alt text](./[현준]%20Image/image-79.png)
    
    💡 **쓰기시 복사로 자식 프로세스 생성**
        ![alt text](./[현준]%20Image/image-80.png)
    
    - 프로세스 생성 시간 절약
    
    - 메모리 절약

- 메모리 사상 파일
    - 디스크의 파일을 메모리에 Mapping 시키고, 메모리 접근하듯이 파일을 사용

        → `read()`, `write()` 호출 없이 파일 데이터 사용

<br>

### 페이지 폴트와 스래싱

- **스래싱** : 페이지 폴트가 반복적으로 발생하는 것, 디스크 입출력 증가 현상

- 📢 스왑-아웃하고, 스왑-인 하는 시간이 매우 증가함

<br>

**[원인]**
1. 다중 프로그래밍이 과도한 경우 : 프로세스가 많은 경우

2. 잘못된 메모리 할당 / 페이지 교체 알고리즘

3. 기본적으로 메모리 량이 적을 때

4. 우연히도 특정 시간에 너무 많은 프로세스가 실행

<br>

## 4. 참조의 지역성과 작업 집합

- **참조의 지역성** : CPU가 짧은 시간내에 일정 구간의 메모리 영역을 반복적으로 참조하는 경향

- **참조의 지역성 특징** 

    - 프로세스가 최근에 참조한 데이터와 코드를 다시 참조하는 경향성

    - 참조의 지역성 **이동**

        - 프로세스가 실행되는 동안 메모리 영역을 옮겨 다니면서 참조의 지역성이 나타남


- **참조의 지역성 형태**
    - 시간 지역성
        - 프로세스에서 지금 참조된 주소가 가까운 미래에 다시 참조될 가능성이 큰 특성

    - 공간 지역성
        - 공간적으로 볼 때, 참조되는 번지의 주변 번지들이 가까운 미래에 참조되는 특성

    - 순차 지역성
        - 데이터가 순차적으로 액세스되는 경향

<br>

### 작업 집합
> 일정 시간 범위 내에 프로세스가 액세스(참조)한 페이지들의 집합

![alt text](./[현준]%20Image/image-81.png)

- 참조의 지역성으로 인해 일정 시간 내에 작업 집합이 뚜렷하게 형성됨

    - 시간이 지나면 페이지 폴트가 줄고 작업 집합이 뚜렷이 형성됨

<br>

> 🔥 **참고**
- **적재 집합** : 주 기억장치에 적재되어 있는 모든 페이지 번호의 모음

- **작업 집합** : 적재 집합 리스트 중에서 특정 시간동안 CPU에 의해 사용된 페이지 번호의 모음

<br>

### 요구 페이징의 필수 알고리즘 2개

1. 프레임 할당 알고리즘 : 프로세스당 할당할 프레임 개수를 결정하는 문제

2. 페이지 교체 알고리즘 : 페이지 폴트 발생 시, 희생 프레임을 결정하는 문제


<br>

## 5. 프레임 할당
> 프로세스에게 작업 집합에 포함된 페이지들을 적재할 충분한 메모리 할당

- **균등 할당**
    - 프로세스에게 모두 동일한 개수의 프레임 할당 
        
        - 👍 단순
        
        - 👎작은 프로세스에는 프레임 낭비, 큰 프로세스에는 페이지 폴트 발생 가능 

- **비례 할당**
    - 프로세스 크기에 비례하여 프레임 할당

        - 👍 많이 필요한 프로세스에게 많은 프레임 할당, 전체적인 페이지 폴트의 수를 줄임

        - 👎 실행 전에 프로세스 크기를 완벽히 알지 못함, 실행 중에 작업 집합을 판단할 필요

<br>

**🤔 그래서 적정 프레임 개수는 몇개?**
> 작업 집합을 약간 넘는 크기가 좋음!

![alt text](./[현준]%20Image/image-82.png)

<br>

### Window에서 메모리 사용량은

![alt text](./[현준]%20Image/image-83.png)

현재 메모리에 적재된 프로세스의 메모리 용량

`Vscode`가 547.2MB를 사용 중인데, 한개의 페이지 크기로 나누면 몇개의 페이지가 메모리에 있는지 알 수 있다!!


<br>

## 6. 페이지 교체

### 페이지 교체란
> 모든 프레임이 사용 중일 때, 메모리 프레임 중 하나를 선택하여 비우고 이곳에 요청된 페이지를 적재하는 과정
![alt text](./[현준]%20Image/image-84.png)

- 현재 **작업 집합에 포함되지 않거나**, 가까운 미래에 참조되지 않을 페이지를 희생 페이지로 선택

- 페이지 폴트 핸들러가 실행

- **희생 프레임** : 비우기로 한 프레임 / **희생 페이지** : 희생 프레임에 들어 있는 페이지

<br>

### 희생 프레임의 선택 범위

- **지역 교체** : 요청한 프로세스에 할당된 프레임 중에서 희생 프레임 선택
    - 한 프로세스에서 발생한 스래싱이 다른 프로세르로 전파되지 않음

    - 스래싱에 대한 대책으로 적합

- **전역 교체** : 전체 메모리 프레임 중에서 선택
    
<br>

### 최적 페이지 교체
> 가장 먼 미래에 사용될 페이지를 교체 대상으로 결정

![alt text](./[현준]%20Image/image-85.png)

- 미래의 페이지 액세스에 대해 모르기 때문에, 구현이 불가!

<br>

### FIFO 
> 가장 오래전에 적재된 페이지 선택하는 방식이며 구현이 단순

![alt text](./[현준]%20Image/image-86.png)

- 페이지가 적재된 시간을 저장해야 함

- 성능이 좋지 않다. 오래 된 페이지에도 자주 사용되는 변수나 코드가 있을 수 있음

<br>

### LRU
> 가장 최근에 사용되지 않았던 페이지 선택

![alt text](./[현준]%20Image/image-87.png)
- FIFO와 동일하지만, 히트가 되면 시간을 조정

- 구현을 위해 프레임에 참조 시간 비트를 추가하여, 시간을 기록하는 방식 → 시간 검사에 많은 오버헤드

- 페이지 테이블에 참조 비트 추가함 (0과 1의 값만 존재) → 0 중에는 어떤 것을 선택할까?

<br>

### Clock : FIFO + LRU
![alt text](./[현준]%20Image/image-88.png)

- 프레임당 1비트의 참조 비트 사용 → 0 또는 1만 존재

- 프레임을 원형 큐로 연결하여 관리

- 포인터가 이동하여, 프레임을 교체함

- 새롭게 적재되거나, 페이지가 **참조될 때마다 해당 프레임의 참조 비트를 1로 설정**

<br>

**교체 알고리즘** : 현재 포인터가 가리키고 있는 프레임에서
- 참조 비트가 0이면, 그 프레임을 희생 프레임으로 선택, 새로 적재된 프레임의 참조 비트는 1로 설정하고 포인터 이동

- 참조 비트가 1이면, 0으로 바꾸고 다음 프레임으로 포인터를 이동해 교체를 검토

<br>

### LFU (Least Frequently Used)

- 각 페이지마다 참조 횟수 카운터가 존재, 카운터 수가 가장 작은 페이지 대치

### MFU (Most Frequently Used)

- 가장 많이 사용한 페이지 교체

- 많이 사용한 페이지는 더 이상 사용하지 않을 것 같다는 가정하에 교체

<br>

## 7. 운영체제의 가상 메모리 관리 정책

### 1. 반입 정책
- 각 페이지를 주 기억장치로 언제 적재할 지 결정하는 정책

- **요구 반입**
    - 페이지 폴트시 필요한 페이지를 프레임에 적재함

- **선반입**
    - 페이지 폴트에 의해 요구된 페이지 + 주변 페이지도 적재함

### 2. 배치 정책
- 적재될 블록이 주 기억장치에 어디에 위치할 것인지 결정하는 정책

### 3. 교체 정책

- 최적 교체 / FIFO / LRU / Clock / LFU / MFU 

- 복합적으로 사용이 가능한 추가적인 알고리즘
    - 프레임 잠금 : 특정 프레임을 교체 검토 대상에서 제외, 잠금 비트로 설정

        - 운영체제 커널 중 주요 자료구조, 입출력 버퍼, 시간이 중요한 영역

    - 베이지 버퍼링 : 교체되는 프레임의 빠른 시간 내의 재사용에 대한 대비
        
        - 선택된 페이지를 즉시 교체하지 않고 어느정도 기간 동안 주기억장치 상에 유지

        - 수정이 있다면 변경페이지 리스트의 뒤쪽에 등록

        - 교체될 페이지가 수정이 없다면 가용페이지 리스트 뒤쪽에 등록

### 4. 적재 집합 관리

> 프레임 할당 기법

- 고정 할당 / 가변 할당

> 교체 점위 관리

- 지역 범위 / 전역 범위

### 클리닝 정책
> 변경된 페이지들을 언제 보조기억 장치에 기록할 지 결정

- 요구 클리닝 : 교체될 때 기록

- 선 클리닝 : 교체 요청이 없어도 운영체제가 일정 간격마다 변경된 페이지들을 보조 기억 장치에 기록

### 6. 부하제어

- 주 기억장치에 적재될 프로세스 수 결정

- **부하제어 방식**
    - 작업 집합 관리 : 적재 집합 관리 과정에서 자동적이며 동적으로 활성 프로세스의 수 결정

    - L=S 규볌 : 폴트간 평균시간 L과 폴트 처리에 필요한 평균 서비스 S가 일치되게

    - 50% criterion : 페이징 장치의 활용도가 50%로 유지되기

    - 클록 정책의 변형 : 바늘의 스캔 속도가 너무 빠르면 멀티 프로그래밍 차수를 낮추고, 너무 느리면 높이는 방법 적용 