
# 프로세스의 문제점과 스레드 등장 배경
프로세스 실행 단위로 하는 멀티태스킹은 세 가지 문제점이 있다.
- 프로세스 생성의 큰 오버헤드
	- 응용 프로그램 실행 시 프로세스를 생성해야 하고 프로세스 생성을 위해 메모리 할당, 부모 프로세스로부터 복사, PCB 생성, 매핑 테이블 생성 등 오버헤드가 큰 문제가 있다.
- 프로세스 컨텍스트 스위칭의 큰 오버헤드
	- 컨텍스트 스위칭 발생 시 오버헤드가 발생한다.
- 프로세스 사이 통신의 어려움
	- 각 프로세스는 독립된 메모리 공간을 점유하기 때문에 프로세스 간 통신을 위한 방법이 필요하다. 이러한 방법으로 커널 메모리를 이용한 방법 등이 있는데 이는 커널 모드와 사용자 모드를 번갈아가며 사용해야 하기 때문에 오버헤드가 발생한다. 

이러한 프로세스 실행 단위의 멀티태스킹의 시간적, 공간적 문제점으로 인한 시스템 속도 저하 문제를 해결하기 위해 새로운 실행 단위인 스레드가 등장했다.
스레드는 프로세스보다 크기가 작고 생성 및 소멸이 빠르고 컨텍스트 스위칭이 빠르며 통신이 쉬운 장점이 있다.
# 스레드
> 프로세스를 컨테이너 역할로 사용하는 실행 단위이자 스케줄링 단위이다.

![{887CF72F-0411-4774-9CF4-2F1C30642CB8}](https://github.com/user-attachments/assets/c41d6c2b-1961-40bf-b5ee-18d9c47a94e9)

- 코드, 데이터, 힙, 스택을 갖고 있는 실체
- 프로세스에 PCB가 있듯이 스레드에는 TCB(Thread Control Block)가 있음
- 스레드 실행 단위에서 프로세스는 스레드의 컨테이너 역할
- 한 프로세스에 속한 스레드는 프로세스의 코드, 데이터, 힙을 공유하고 스택 공간을 나누어 독점적으로 사용함
- 공유 공간을 이용하여 한 프로세스 내부의 스레드들끼리 통신함
	![{A3F692CC-C19D-46C2-A6A0-E05513D2D53B}](https://github.com/user-attachments/assets/20c51abb-46b6-41b9-b82b-8bf654fad14a)
- 스레드가 실행할 작업은 함수로 작성하여 운영체제에 요청
	- 요청을 받은 운영체제는 스레드를 생성하고 동시에 TCB를 생성하여 함수의 주소를 스레드 실행 시작 주소로 TCB에 등록(즉, 함수 == 스레드)
	- 운영체제는 TCB 리스트로 전체 스레드 관리

### 스레드 주소 공간
> 프로세스의 주소 공간 내에 스레드 주소 공간 형성됨

스레드는 프로세스 공간에서 공유 공간과 스레드 개별 사적 공간을 나누어 사용한다.
- **스레드 사이 공유 공간**
	- 프로세스의 코드 영역
	- 프로세스의 데이터 영역
		- 통신 공간으로 사용
	- 프로세스의 힙 영역
- **개별 스레드 사적 공간** 
	- 스레드의 스택 영역
	- **스레드의 로컬 스토리지(TLS)**
		- 프로세스의 힙 또는 스택에 할당됨

- 스레드의 주소 공간
	- **스레드 코드 영역**
	- **스레드 데이터 영역**
		- 공간1: 프로세스 데이터 영역
		- 공간2: 개별 스레드의 전용 변수 공간(TLS: 스레드 로컬 스토리지)
	- **스레드 힙 영역**
	- **스레드 스택 영역** 
		- 개별 스레드 사용자 스택 영역
		- 개별 스레드 커널 스택 영역
![{8CF690B2-1445-49C7-B9AF-0423BCEA25E5}](https://github.com/user-attachments/assets/5145be67-94e9-4be4-82ee-2f09c38cb809)

### 스레드 생명주기(상태)
스레드의 상태는 TCB에 저장됨

##### 스레드 상태
- **준비 상태**: 스케줄(실행) 대기 상태
- **실행 상태**: 스레드가 CPU에 의해 실행 중인 상태
- **대기 상태**: I/O 요청이나 시스템 호출에 의해 중단된 상태
- **종료 상태**: 스레드가 종료한 상태
![{528C2DFF-976B-43B7-A247-280D2BCA229C}](https://github.com/user-attachments/assets/eacc3633-02dd-48b0-a1d2-7c0419e961aa)

##### 스레드 운용
- 생성
	- 프로세스 생성 시 자동으로 main 스레드 생성됨
	- 새로운 스레드는 시스템 호출이나 라이브러리 함수를 호출하여 생성 가능
- 종료
	- 프로세스 종료
		- 프로세스를 종료하면 스레드가 종료됨
		- 모든 스레드를 종료하면 프로세스가 종료됨
	- 스레드 종료
		- 스레드만 종료 
- 조인
	- 다른 스레드가 종료할 때까지 대기하는 상태
	![{3F335E98-B128-440D-9F8D-D00EDF615F52}](https://github.com/user-attachments/assets/9df12a34-4fd6-4ae2-8584-3ce13247d123)
- 양보
	- 스레드가 자발적으로 실행 중단하고 다른 스케줄에게 실행 양보
### 스레드 컨텍스트
> 현재 실행중인 스레드의 일체의 상황(CPU 레지스터들에 저장)

스레드 컨텍스트는 일단 컨텍스트와 다르게 CPU 레지스터들의 값만으로 정의한다. 왜냐하면 일단 문맥 교환은 CPU 정보와 메모리로 이루어져 있는데 메모리는 컨텍스트 스위칭시에도 유지되기 때문이다.

##### 스레드 컨텍스트 정보 - CPU 레지스터들
- **PC 레지스터**
	실행 중인 코드 주소
- **SP 레지스터**
	실행 중인 함수의 스택 주소
- **상태 레지스터**
	현재 CPU의 상태 정보
- **기타 레지스터**

컨텍스트 스위칭 될 때 관련 정보를 모두 TCB에 저장해두었다가 복귀 시 TCB에서 CPU로 정보를 복귀한다.

#### TCP(Thread Control Block)
> 스레드에 관한 정보를 담은 구조체

- 스레드 엔터티, 스케줄링 엔터티라고도 불림
- 커널 영역에 만들어지고 커널이 관리함
- 스레드 생성 시 커널에 의해 생성되고 스레드 소멸 시 같이 소멸

##### TCP와 PCB의 관계
> PCB는 TCB들을 링크드 리스트로 연결하여 관리

![{A135D4BF-6B25-4698-8885-FFEEA2CB3E36}](https://github.com/user-attachments/assets/ff54992d-d063-4337-a227-32d4ae7465a3)

### 스레드 준비 리스트와 블록 리스트
스레드를 링크드 리스트로 연결할 때 준비 리스트와 블록 리스트로 나누어 연결한다.
#### 준비 리스트
준비 상태에 있는 스레드들의 TCB를 연결하는 링크드 리스트
#### 블록 리스트
블록 상태에 있는 스레드들의 TCB를 연결하는 링크드 리스트 

##### 다중 블록 리스트
I/O 장치는 매우 종류가 많다. 모든 I/O 장치를 하나의 블록 리스트에 연결하면 매우 비효율적이기 때문에 I/O 장치 별로 블록 리스트를 만들어서 연결한다.
![{6EE2B780-41FA-4929-95B2-11B844B9F6E2}](https://github.com/user-attachments/assets/28e96c07-a3cb-428e-80b2-84350bf5e585)

#### 스레드 컨텍스트 스위칭
스레드 컨텍스트 스위칭은 다음 두 가지 경우 실행된다.
- 시스템 호출
- 인터럽트 발생 -> 커널에서 인터럽트 서비스 루틴 실행 
현재 CPU 컨텍스트를 TCB에 저장하고, 새로운 스레드의 TCB를 CPU에 적재하여 스레드 컨텍스트 스위칭 실행
![{40DA08AA-9388-4D56-BAC5-EB2B2904FFB5}](https://github.com/user-attachments/assets/3498058c-3ee0-413d-92b4-78c074fcd1d1)

- 스레드 스위칭 발생하는 4가지 경우
	- 자발적으로 양보
	- 시스템 호출하여 블록되는 경우
	- 타임 슬라이스 소진한 경우
	- I/O 장치로부터 인터럽트 발생한 경우

##### 스레드 컨텍스트 스위칭 과정
스위칭 과정은 아래와 같다.
![Pasted image 20241007000924](https://github.com/user-attachments/assets/483229ea-bad7-40fa-93ce-f1d75945b9a0)

- 동일 프로세스 내 다른 스레드로 스위칭하는 경우
	- 공유 공간을 그대로 사용하기 때문에 프로세스를 바꾸는 것보다 오버헤드가 적음
- 다른 프로세스의 스레드로 스위칭하는 경우
	- 다른 프로세스로 교체되면 CPU가 실행중인 주소 공간이 바뀌기 때문에 추가적인 오버헤드 발생
	- 즉, 프로세스의 공유 공간까지 모두 바꿔야해서 추가적인 오버헤드 발생

## 사용자 레벨 스레드와 커널 레벨 스레드 
스레드 스케줄링 주체에 따라 두 종류의 스레드로 구분한다.
![{B0C85733-4053-4B93-BB0F-70A91D0DFD26}](https://github.com/user-attachments/assets/bac07637-28af-4e12-a10c-d8d025cdd892)

### 커널 레벨 스레드(KLT: kernel-level thread)
> 커널이 생성하고 커널이 스케줄링하는 스레드로써 TCB는 커널 공간에, 스레드 주소 공간(코드, 데이터)는 사용자 공간에 위치하는 스레드

- 장점
	- 여러 개의 CPU를 사용할 경우 서로 다른 CPU에서 스레드들을 병렬로 수행할 수 있다.
- 단점
	- 동일 프로세스 내 스레드라도 전환 시 커널을 호출해야 하므로 커널 모드 전환에 의한 오버헤드 발생 

아래 사진과 같이 PCB, TCB 모두 커널 공간에 위치하고 스레드 주소 공간은 사용자 공간에 위치한다.(순수한 커널 레벨 스레드는 둘 다 커널 레벨에 위치)
![{18FD8B2F-DA0F-465B-AC0C-4E9B291E7F61}](https://github.com/user-attachments/assets/26884195-e42d-4063-9cd4-21772805525c)

### 사용자 레벨 스레드(ULT: user-level thread) 
> 스레드 라이브러리에 의해 사용자 공간에서 생성되고 스레드 라이브러리에 의해 스케줄링되는 스레드로써 TCB가 사용자 공간에 위치하는 스레드

- 커널은 스레드 존재를 모르기 때문에 커널은 프로세스 단위로만 단기 스케줄링 한다.
- 스레드 라이브러리란
	- 스레드 생성, 제거, 데이터 전송, 동기화, 스케줄링, 문맥교환 등 스레드에 대한 전반적인 관리를 담당함

- 스레드 스케줄링 방법
	- 커널은 프로세스 단위로만 스케줄링
	- 선택된 프로세스는 자신에게 포함된 스레드 라이브러리 내부의 스케줄러를 이용해 스레드를 스케줄링 함

- 장점
	- 동일 프로세스 내의 스레드 교환/교체시 커널 모드 권한 불필요(스레드가 사용자 공간에 있기 때문)
	- 커널과 무관한 사용자 공간에 있는 스레드 라이브러리를 사용하기 때문에 운영체제와 상관 없이 사용 가능
- 단점
	- 한 스레드가 블록을 유발하는 시스템 호출을 할 경우 프로세스 자체가 블록되어 모든 스레드가 블록됨
		- ULT는 커널이 프로세스 단위로만 실행하기 때문에 한 스레드가 블록을 유발하더라도 시스템 호출에 의해 커널이 프로세스 자체를 블록해버림

![{0A9E76EA-D56D-4FB9-B5DC-E6FDCDF93DDF}](https://github.com/user-attachments/assets/ddbc9f27-a571-42f6-85ac-9c6e442be2ce)

## 멀티 스레드 
> 사용자 레벨 스레드(ULT)를 시스템에서 스케줄 되고 실행되도록 구현하는 방법

ULT를 KLT로 매핑 시키는 방법에 따라 3가지 방식이 존재한다.
#### N:1 매핑
> 한 프로세스에 속한 여러 개의 ULT를 1개의 KLT로 매핑 
#### 1:1 매핑
> ULT 1개당 1개의 KLT로 매핑
#### N:M 매핑
> 여러 개의 ULT를 여러 개의 KLT로 매핑


# 요약 정리
- 프로세스의 큰 오버헤드를 줄이기 위한 방법으로 스레드가 만들어짐
- 한 프로세스에 여러 개의 스레드가 존재
- 프로세스의 코드, 데이터, 힙 영역은 공유 공간으로 사용하고 스택 영역은 스레드들끼리 나누어 독립적인 공간으로 사용
- 공유 공간을 사용하여 한 프로세스 내의 스레드들끼리 통신이 가능하기 때문에 한 프로세스 내부의 스레드들끼리의 스위칭은 프로세스 스위칭에 비해 매우 빠름
- PCB처럼 TCB가 존재하고 TCB에는 스레드 관련 정보가 들어 있음
- 스레드는 커널 레벨 스레드와 사용자 레벨 스레드가 존재하고 스레드의 장점을 사용하기 위해서 거의 대부분이 커널 레벨 스레드임
