# 컴퓨터 시스템과 하드웨어
## 컴퓨터 시스템 계층
- 시스템 계층 종류
	- 응용 프로그램 계층
	- 운영체제 계층
	- 컴퓨터 하드웨어 계층

- 컴퓨터 시스템 계층 구조의 특징
	- 운영체제는 하드웨어를 독점적으로 지배함
	- 사용자나 응용 프로그램은 반드시 운영체제를 통해서만 하드웨어에 접근할 수 있음

## 하드웨어 구성
### CPU
> 프로그램 코드 해석하여 실행하는 하드웨어

#### CPU 구성 요소
![Pasted image 20240927194006](https://github.com/user-attachments/assets/d511a59b-f64c-4371-9475-c62653f71f24)
- **ALU**(Arithmetic and Logical Unit)
	- CPU 내부에서 계산을 담당하는 산술 논리 연산 장치
	- **계산 과정**
		- 레지스터로부터 피연산자를 얻고 제어장치로부터 수행할 연산(제어 신호)을 지시 받음
		- 피연산자를 연산한 후 결과 값을 레지스터에 저장하고 계산 과정에서 나오는 부가적인 정보들인 플래그는 플래그 레지스터에 저장
- **레지스터**(Register)
	- CPU 내부에 있는 고속 메모리
	- 레지스터 종류
		- **PC(Program Counter)**
			- 다음에 실행할 명령의 메모리 주소 저장
		- **IR(Instruction Register)**
			- 현재 실행하기 위해 메모리로부터 읽어 온 명령 저장
		- **SP(Stack Pointer)**
			- 스택의 톱 메모리 주소 저장
		- **상태 레지스터(status register)**
			- CPU의 상태 정보나 인터럽트 금지 등의 제어 정보 저장
		- **데이터 레지스터들(data registers)**
			- 연산에 사용되거나 사용될 데이터들 저장
		- **기타 특수용도 레지스터들**
			- 페이지 테이블이 저장된 메모리 주소를 가리키는 레지스터 등
- **제어장치**(Control Unit)
	- 명령어 읽고 해석하는 제어장치

#### 32비트 컴퓨터(32비트 CPU)
32비트 CPU를 가진 컴퓨터
- 32비트 CPU란?
	- 한 번에 32비트를 처리할 수 있는 내부 구조를 갖는 CPU
	- CPU에 32개의 주소선이 있음
		- CPU 액세스 범위: 2^32 개의 서로 다른 주소
		- 최대 엑세스 가능한 메모리 크기: 4GB(2^32)
![{31927F1C-939B-44CF-B29C-FDD75C20A955}](https://github.com/user-attachments/assets/f1cacaf4-f37b-4bfb-b607-10fff664d34b)
	

#### CPU 명령 처리 과정
- 100번지 메모리에 저장된 명령을 실행하는 과정
![Pasted image 20240927193931](https://github.com/user-attachments/assets/81660d89-1f68-4290-a99a-303365860015)
1. CPU는 PC 레지스터가 가리키는 주소인 100을 주소 버스에 싣는다.
2. 메모리는 100번지 메모리에 저장된 데이터인 mov eax, [300]을 데이터 버스에 싣는다.
3. CPU는 데이터 버스에 담긴 값들을 IR 레지스터에 저장하고 PC를 다음 번지인 300 번지로 수정한다.
4. CPU는 데이터 주소인 300을 주소 버스에 싣는다.
5. 메모리는 300번지 메모리에 저장된 값인 50을 데이터 버스에 싣는다.
6. CPU는 데이터 버스로부터 50을 임시 데이터 레지스터에 저장한다.
7. 이제 CPU가 명령을 해석하고 실행한 뒤 명령의 결과를 eax 레지스터에 저장한다. 
### 메모리
> 프로그램 실행 전 코드와 데이터 적재되는 공간

- 메모리 공간 4가지
	- 코드(code) 공간
		- 프로그램 코드 적재
	- 데이터(data) 공간
		- 전역 변수들이 적재되는 공간
	- 힙(heap) 공간
		- 프로그램에서 동적 할당 받는 공간
	- 스택(stack) 공간
		- 함수가 호출될 때 매개변수, 지역변수, 함수 실행 후 돌아갈 주소, 함수가 저장해 놓은 값 저장

#### 스택(stack) 공간
> 메모리 일부를 스택으로 사용하도록 할당된 공간

- 운영체제는 각 프로그램에게 스택 공간 할당
- SP 레지스터는 현재 CPU가 실행 중인 프로그램의 스택 맨 위 주소를 가리킴
- 스택 공간에는 함수가 호출될 때 매개변수, 지역변수, 함수 실행 후 돌아갈 주소, 함수가 저장해 놓은 값이 저장된다. 즉, 임시적으로 사용할 값들이 저장된다고 생각하면 됨

![Pasted image 20240927193920](https://github.com/user-attachments/assets/36529be1-4258-4cd0-84aa-c394562b32ec)

#### 컨텍스트(Context)
> 한 프로그램이 실행 중인 일체의 상황 or 상황 정보
- CPU 레지스터들의 값
- 메모리 안의 코드 정보

##### 컨텍스트 스위칭(문맥 교환)
> CPU가 현재 프로그램의 실행을 중지하고 다른 프로그램을 실행하는 작업

- 컨텍스트 스위칭 과정
	1. 현재 실행중인 프로그램의 컨텍스트(CPU 레지스터들의 값)를 메모리에 저장
	2. 새로 실행시킬 프로그램의 저장된 컨텍스트(CPU 레지스터들의 값)를 CPU에 복귀
![Pasted image 20240927221922](https://github.com/user-attachments/assets/4d0cdec1-89e2-4f94-b05e-bef0063e4e3d)






### 캐시 메모리
> 메모리의 느린 속도를 개선하여 실행 속도를 높이기 위해 CPU, 메모리 사이에 위치
### 버스
- 하드웨어 간의 데이터 신호 이동하는 여러 가닥의 선 다발
- 버스의 종류
	- 주소 버스
	- 데이터 버스
	- 제어 버스
- 목적에 따른 버스 구분
	- 시스템 버스
		- CPU, 캐시 메모리, 메모리 등 데이터 이동하는 버스
	- 입출력 버스
		- 입출력 데이터 이동하는 버스

# 컴퓨터 시스템과 운영체제
## 컴퓨터 시스템 계층 구조
컴퓨터 시스템은 아래 사진과 같이 계층 구조로 이루어져 있다.
![image](https://github.com/user-attachments/assets/8edafaf4-8f9c-42e1-9eeb-5c3303183169)

- 계층 구조로 설계된 이유
	계층간 독립성을 확보하여 다른 계층의 상세한 내용을 몰라도 자신의 일만 하면 정상적으로 작동하고 하드웨어가 바뀌어도 응용프로그램이 돌아갈 수 있도록 하기 위해 계층 구조로 설계되었다.
	- 사용자는 운영체제, 하드웨어를 몰라도 응용프로그램만으로 사용할 수 있다.
	- 응용프로그램은 하드웨어를 몰라도 사용할 수 있다.
	- 운영체제는 하드웨어 관련 작업을 드라이버에 모두 요청한다.

## 운영체제
- 운영체제의 필요성
	만약 운영체제가 없다면 응용프로그램이나 사용자가 직접 운영체제가 하는 프로세스 관리, 메모리 관리, 장치 관리, 파일 시스템 관리, 입출력 관리 등 운영체제가 하는 일을 직접 해야 한다. 충돌, 관리, 보안에 문제가 생길 수 있기 때문에 이를 효율적으로 하기 위해 운영체제가 필요하다.

### 운영체제의 역할
> 사용자/응용프로그램과 하드웨어 사이의 인터페이스 역할
- 운영체제가 하드웨어를 독점하고 응용 프로그램이 직접 하드웨어를 다루지 못하게 차단하여 충돌 방지(하드웨어를 사용하고 싶다면 운영체제에 요청하여 시스템 호출을 통해서만 사용할 수 있음)
- 응용프로그램과 하드웨어 사이의 인터페이스 역할
- 응용프로그램의 실행 순서 제어(스케줄링 기법)
- 응용프로그램 사이의 통신 중계
### 운영체제의 기능
- 컴퓨터의 4대 자원을 관리한다.
	- 프로세스, 스레드 관리
		- 프로세스/스레드 실행, 스케줄링, 컨텍스트 스위칭, 동기화 등
	- 메모리 관리
		- 메모리 할당/반환, 메모리 보호, 가상 메모리 기술 등
	- 파일, 파일 시스템 관리
	- 하드웨어 장치 관리
### 운영체제의 구성 요소
> 운영체제는 커널, 도구(tool) 그리고 디바이스 드라이버로 이루어져 있음

![image](https://github.com/user-attachments/assets/fd512445-8128-4472-8441-4e018a696fc9)
#### 커널
> 운영체제의 핵심 기능으로써 CPU, 메모리 등 컴퓨터 자원을 제어하고 관리하는 코드와 자료구조들
> 커널을 이용하려면 **시스템 호출**을 통해서만 이용할 수 있음

- 시스템 부팅 시 커널 공간에 적재된 함수들과 데이터의 집합을 커널이라 부른다.

##### 커널 구분
- **모놀리식(Monolithic) 커널 (단일 커널)**
	커널의 모든 기능이 하나의 덩어리로 구현된 커널(Unix, Linux 등)
- **마이크로(Micro) 커널**
	기본적인 핵심 기능만 구현하고 나머지 기능은 서버에 구현하여 마치 프로그램처럼 필요할 때만 불러서 사용하는 방식(주로 임베디드에서 사용)
- **하이브리드(혼합형) 커널**
	모놀리식 커널과 마이크로 커널의 장단점을 섞은 커널(Windows)

#### 도구 SW와 GUI
> 사용자가 컴퓨터를 편리하게 사용할 수 있도록 제공하는 툴 소프트웨어 혹은 툴 응용프로그램
ex. GUI, 디렉토리 탐색기, 터미널, 작업 관리자 등
#### 디바이스 드라이버
> 하드웨어 디바이스를 제어하고 입출력 담당하는 소프트웨어

디바이스마다 담당 드라이버가 있다.


# 커널과 시스템 호출

## 커널에 접근하는 두 가지 인터페이스(시스템 호출, 인터럽트)
커널에 접근하려면 시스템 호출이나 인터럽트를 이용해야만 접근할 수 있다.
![image](https://github.com/user-attachments/assets/6ed38d63-137a-4f29-ade5-3213ffd4e409)
### 시스템 호출
> 커널과 응용프로그램 사이의 인터페이스
> 응용 프로그램에서 커널을 호출하는 방법

운영체제는 시스템 호출 라이브러리를 통해 시스템 호출 함수를 제공한다.
- 파일 읽기, 메모리 할당, 프로세스 정보 보기, 프로세스 생성 등 → open(), close(), read(), fork(), exit(), 등의 시스템 호출 함수가 시스템 호출 라이브러리에 해당된다.

> 시스템 호출 라이브러리(커널 API)란?
> 시스템 호출 함수로써 시스템 호출을 진행하여 커널 모드로 바꾸고 커널로 진입하여 커널 함수를 실행하는 라이브러리
> 운영체제마다 시스템 호출 함수의 이름 다름(ex. 프로세스 종료 함수: windows(ExitProcess) / Linux: _exit)

### 인터럽트
> 커널과 하드웨어 장치 사이의 인터페이스
> 하드웨어에서 커널을 호출하는 방법 

장치 입출력 완료, 입출력 장치 입력 등 다양한 이벤트를 CPU에 알리는 처리 방법이다.
- **인터럽트 발생 과정**
	1. CPU 하던 일 중단하고 인터럽트 서비스 루틴(ISR: Interrupt Service Routine) 실행(ISR은 대부분 디바이스 드라이버 내부에 존재)
	2. ISR을 커널 영역에 적재
	3. CPU는 ISR을 실행하고 끝나면 기존에 하던 작업 마저 진행
![image](https://github.com/user-attachments/assets/4f62a2af-44e3-460a-b368-d51584a14cf1)
## 응용 프로그램 자원 접근 문제
다수의 응용 프로그램이 하나의 운영체제어서 동시에 실행되는 형태이기 때문에 응용 프로그램이 직접 컴퓨터 자원에 접근하면 아래와 같은 충돌과 훼손이 발생할 수 있다.
- 다른 응용 프로그램이 적재된 메모리 훼손
- 다른 응용 프로그램이 만든 파일 훼손
- 다른 응용 프로그램이 적재된 커널 영역 훼손

이러한 문제들을 예방하기 위해 하드웨어 자원에 대한 모든 접근 권한을 커널(운영체제)에만 부여하여 응용 프로그램이 직접 자원에 접근할 수 없도록 한다.
### 구체적인 해결 방법
![{178983A3-F306-44E0-9A9F-E4D18F9F6129}](https://github.com/user-attachments/assets/426e1e9f-ce86-4ae3-992e-97bea4b60c08)
1. 메모리 공간을 **사용자 공간, 커널 공간**으로 분리
	- 응용 프로그램은 사용자 공간에, 커널은 커널 공간에만 적재
2. CPU 실행 모드를 **사용자 모드, 커널 모드**로 분리
	- 사용자 공간에서 커널 공간에 직접 접근 불가능
3. 응용 프로그램이 커널 기능을 이용하고 싶다면 시스템 호출을 통해서만 이용 가능

### 사용자 공간과 커널 공간
![{81CDDCC0-A42B-4A34-A6C6-9701DC9A66BB}](https://github.com/user-attachments/assets/3c21c749-ada1-4eb4-b493-aa2ad618e229)
#### 사용자 공간
- 응용 프로그램 적재
- 응용 프로그램 변수 생성 및 동적 할당 받는 공간
- 사용자 모드로만 동작

![{54645008-3E03-468F-97EB-E19177B0EF4D}](https://github.com/user-attachments/assets/e57abc83-90cd-40e0-bb67-14ac5e32e063)

#### 커널 공간
- 커널 코드, 커널 데이터 등 커널만 사용하는 공간
- 디바이스 드라이버 포함
- 커널 모드로만 동작

### 사용자 모드, 커널 모드
> CPU는 사용자 모드와 커널 모드 중 하나의 모드로 실행

사용자 모드에서 커널 모드로 전환하는 방법은 시스템 호출, 인터럽트 발생 두 가지 방법만 존재한다.

CPU의 모드를 나타내는 상태 레지스터에 따라 동작한다.
SV 레지스터가 1이면 사용자 모드로 동작하고 0이면 커널 모드로 동작한다.
![image](https://github.com/user-attachments/assets/d9695285-2c17-4efa-97ed-e8b7b32f0bff)
![image](https://github.com/user-attachments/assets/dc37fb3f-b036-4679-b1a5-1fc4f70a99a9)
![image](https://github.com/user-attachments/assets/a077395b-e308-45dc-a650-1076efe971df)
#### 사용자 모드
사용자 공간만 접근 가능하고 특권 명령은 실행 불가능하다.
> 특권 명령이란?
> 입출력 장치로부터의 입출력(I/O), 시스템 중단, 컨텍스트 스위칭, 인터럽트 금지 등 특별한 목적으로 설계된 CPU 명령이다.
> 커널 모드에서만 실행된다.
#### 커널 모드
사용자 공간, 커널 공간 모두 접근 가능하며 특권 명령 실행 가능하다. 

### 가상(논리) 주소 공간
> 사용자/응용 프로그램이 인식하는 주소 공간
> 실제 물리적 주소가 아닌 가상 주소를 이용하고  CPU/운영체제가 가상 주소를 물리적 주소로 바꾸어 실행

사용자나 응용 프로그램은 프로그램이 물리 주소(메모리 주소)를 0번지부터 순서대로 배치 및 실행되며, 실행 시 CPU의 전체 주소 공간(물리 주소 공간)을 혼자만 사용한다고 착각한다. 하지만 실제로는 물리 주소는 순서대로 배치되지 않으며, 물리 주소 공간은 여러 응용 프로그램이 운영체제에 의해 나누어 사용된다. 이 과정에서 운영체제는 가상 메모리를 사용하여, 각 프로그램이 마치 자신만의 독립된 메모리 공간을 사용하는 것처럼 보이게 하며, 실제 물리 메모리와 가상 메모리 간의 매핑을 통해 효율적으로 메모리를 관리한다. 이를 통해 충돌을 방지하고, 메모리 자원을 최적화하며, 다중 작업을 안전하게 수행할 수 있게 된다.
아래 사진과 같이 각 응용 프로그램은 가상 주소를 갖고 있지만 실제 실행 시 운영체제에 의해 실제 물리 주소로 바꾸어 실행한다.

![image](https://github.com/user-attachments/assets/8bdb1ee6-fbb4-4c0f-a7bb-ed0e7bc4ac76)
#### 가상 주소 --(매핑)-> 물리 주소
- 실제 물리 메모리에는 현재 실행중인 가상 주소 공간만 적재
- 가상 주소 공간은 주소 매핑 테이블(운영체제 소유)을 통해 물리 메모리 주소로 매핑
- 여러 응용 프로그램이 물리 메모리를 나누어 사용
![image](https://github.com/user-attachments/assets/c33af201-ecd1-4f4d-bb82-8cb5515a6db2)
