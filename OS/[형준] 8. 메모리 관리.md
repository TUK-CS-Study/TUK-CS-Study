# 메모리 계층 구조
메모리는 컴퓨터의 여러 곳에 계층적으로 존재한다.
![alt text](./[형준]%20Image/image-16.png)

- 메모리 종류
  - CPU 레지스터 - CPU 캐시 - 외부 캐시 메모리(요즘엔 CPU 내장) - 메인 메모리 - 보조 기억 장치
  - 레지스터에서 보조 기억 장치로 갈수록 용량↑, 가격↓, 속도↓
  - 메인 메모리 - 메모리 계층 구조의 중심
    - 보조 기억장치는 CPU 실행 불가능
    - 캐시, 레지스터 메모리는 용량이 너무 작음

    ![alt text](./[형준]%20Image/image-17.png)

- 메모리 계층화의 목적
  CPU는 메모리에 있는 프로그램 코드들에 접근하여 실행해야 한다.
  - **성능 최적화 목적**
    - CPU는 매우 빠른데, 메인 메모리(RAM)와 저장 장치(HDD, SSD)의 속도가 상대적으로 느리기 때문에 캐시 메모리와 같은 빠른 메모리를 중간에 두어 속도 차이를 보완
  - **메모리 접근 시간 감소 목적**
    - 자주 사용되는 데이터를 빠른 메모리에 저장하고, 덜 사용되는 데이터는 느린 메모리에 저장함으로써 평균적인 메모리 접근 시간을 최소화

    즉, 자주 사용하는 코드를 빠른 메모리에 저장해서 CPU와 메인 메모리 사이의 속도 차이를 보완하기 위해 메모리 계층화를 사용한다.

- 메모리 계층에서 코드와 데이터 이동 과정
  ![alt text](./[형준]%20Image/image-18.png)

- 메모리 계층화의 성공 이유 - 참조의 지역성
  작은 캐시에 당장 실행할 코드와 데이터의 일부분만 두는 데 효과적인 이유는 **참조의 지역성** 덕분이다.
  > [!NOTE] 참조의 지역성
  > 동일한 값 또는 해당 값에 관계된 기억장치의 주변 위치가 자주 액세스되는 특성으로 **지역성의 원리**라고도 불림

  - 공간(spatial) 지역성

    특정 블록의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향으로, 참조된 메모리 근처의 메모리를 참조
  - 시간(temporal) 지역성

    최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향으로, 참조했던 메모리는 빠른 시간에 다시 참조될 확률 높음
  - 순차(sequential) 지역성(공간 지역성의 일부로 보기도 함)

    데이터가 순차적으로 액세스되는 경향으로, 프로그램 내의 명령어가 순차적으로 구성되어 있다는 것이 대표적인 경우

# 메모리 주소
컴퓨터에서 메모리 관리를 위해 사용하는 주소 개념이다.

## 절대 주소와 상대 주소
> 주소 공간에서의 위치와 관련한 주소의 개념

### 절대 주소(absolute address)
> 메모리의 실제 주소(물리 주소)


### 상대 주소(relative address)
> 프로세스의 논리(가상) 주소 공간에서 사용하는 논리 주소의 또 다른 표현으로써 임의의 주소를 기준으로 얼마만큼 떨어져 있는 지를 표현하는 상대적인 주소(offset)

- 논리 주소 공간에서 100번지
  - 0번지 기준
    - +100
  - 30번지 기준
    - +70
  - 120번지 기준
    - -20

### 상대 주소를 절대 주소로 변환
CPU는 프로세스를 실행할 때 논리(상대)주소를 사용하므로 실제 메모리에 접근할 때는 절대 주소로 변환해서 접근해야 하기 때문에 변환 작업이 필요하다.

- 절대 주소 == 상대 주소 + base(재배치) 레지스터 값
- 논리 주소 40번지를 접근하는 경우
  - 프로세스의 논리 주소 공간 40번지는 0번지를 기준으로 상대 주소는 +40
  - 이 프로세스의 논리 주소 공간이 물리 메모리 360번지(base 레지스터 값)부터 할당
  - MMU에 의해 물리 주소로 변환하면 상대 주소인 +40과 base 레지스터 값(360)을 더한 값인 400이 된다.

  ![alt text](./[형준]%20Image/image-19.png)

#### 실제 변환 과정과 메모리 보호 방법
- base(재배치) 레지스터
  - 실행중인 프로세스에게 할당된 물리 메모리의 시작 주소
- 주소 레지스터
  - CPU가 액세스하는 논리 주소
- limit(경계) 레지스터
  - 실행중인 프로세스에게 할당된 메모리 크기

- 정상적인 접근의 경우
  - CPU가 300번지 논리 주소에 접근하는 경우 MMU가 base 레지스터와 주소 레지스터 값을 더해서 1300번지의 물리 주소로 연결한다.
- 비정상적인 접근의 경우
  - CPU가 900번지의 논리 주소에 접근하는 경우 프로세스에게 할당된 메모리 범위(limit 레지스터 값)를 넘어가므로 MMU가 운영체제에 이를 알려서 해당 프로세스의 사용을 중지시킴으로써 **메모리를 보호** 한다.

![alt text](./[형준]%20Image/image-29.png)

## 물리 주소와 논리/가상 주소
> 프로세스/CPU와 (물리) 메모리 사이에서 실제로 사용하는 주소의 개념



### 물리 주소(physical address)
> 물리 메모리(RAM 등)에 매겨진 주소, 하드웨어에 의해 고정된 메모리 주소

- 0에서 시작하는 연속되는 주소 체계이고 전체 시스템에 하나 밖에 존재하지 않는 주소이다.

### 논리/가상 주소(logical address/virtual address)
> 개발자나 프로세스가 프로세스 내에서 사용하는 주소

- CPU 내에서 프로세스를 실행하는 동안 다루는 CPU 내부 주소도 논리 주소
- 어떤 프로세스 내에서 0 번지 부터 시작하여 연속적으로 매겨지는 주소 체계
- 컴파일러와 링커에 의해 매겨진 주소

- 사용자나 프로세스는 절대 물리 주소를 알 수 없고 물리 메모리에 접근하기 위해서는 MMU를 통해 물리 주소로 변환하여 접근해야 한다.

#### MMU(Memory Management Unit)란?
> 논리 주소를 물리 주소로 바꾸는 하드웨어 장치

- CPU가 특정 프로세스를 실행하면 논리 주소가 할당되어 논리 주소만을 사용한다.
- 메모리에 접근하려면 논리 주소가 아닌 실제 메모리 주소인 물리 주소로 접근해야 한다.
- 이때 CPU는 MMU를 거쳐 논리 주소를 물리 주소로 변환하여 메모리에 접근한다. 
![alt text](./[형준]%20Image/image-20.png)

# 메모리 할당 정책
> [!NOTE] 메모리 할당(메모리 파티션)
운영체제가 새 프로세스를 실행 시키거나 실행 중인 프로세스가 추가적인 메모리를 필요로 할 때, 물리 메모리를 할당하는 작업으로써 해당 프로세스를 위한 별도의 메모리 파티션을 만들고 그 안에 프로세스를 할당한다.

- 메모리 할당은 커널이 담당
- 프로세스 실행은 할당된 메모리 공간에서 실행되므로 할당된 메모리 공간에 대한 보호가 필요

![alt text](./[형준]%20Image/image-21.png)
![alt text](./[형준]%20Image/image-22.png)
## 연속 메모리 할당
> 프로세스별로 연속된 한 덩어리(파티션)로 메모리에 할당

- MS-DOS와 같이 과거 운영체제에서 사용하던 할당 방법
- 현재 사용하는 운영체제는 분할 메모리 할당 방법을 사용함

### 고정 크기 할당
>메모리를 고정 크기의 파티션으로 나누고 프로세스당 하나의 파티션 할당

![alt text](./[형준]%20Image/image-23.png)

### 가변 크기 할당
> 메모리를 (필요시 마다) 동적으로 가변 크기의 파티션으로 나누고 프로세스당 하나의 파티션 할당

![alt text](./[형준]%20Image/image-24.png)

#### 홀 선택 알고리즘/동적 메모리 할당
- 운영체제는 메모리 할당 리스트를 갖고 있다.
- 가변 크기 할당에서 프로세스를 파티션에 할당할 때 할당 리스트를 참고하여 홀을 선택하는 알고리즘은 3종류가 있다.

- first-fit(최초 적합)
  - 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀 선택
  - 할당 속도는 빠르지만 내부 단편화가 발생할 가능성이 있다.
- best-fit(최적 적합)
  - 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 작은 홀 선택
  - 크기 별로 홀이 정렬되어 있지 않다면 전부 검색해야 하는 문제가 있다.
- worst-fit(최악 적합)
  - 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 큰 홀 선택
  - 크기 별로 홀이 정렬되어 있지 않다면 전부 검색해야 하고 내부 단편화 문제가 있다.

![alt text](./[형준]%20Image/image-30.png)


### 단편화(fragmentation)
> 프로세스에게 할당할 수 없는 작은 조각 메모리들이 생기는 현상, 조각 메모리를 홀(hole)이라고 부름

- 단편화는 연속 메모리 할당 뿐만 아니라 모든 메모리 할당 방식에서 발생할 수 있다.


#### 내부 단편화(internal fragmentation)
파티션보다 작은 프로세스를 할당하는 경우, 할당된 파티션 내부에 홀(조각 메모리)가 생기는 현상
![alt text](./[형준]%20Image/image-27.png)

파티션보다 작은 프로세스를 할당하는 경우, 할당된 파티션 내부에 홀(조각 메모리)가 생기는 현상을 말한다.

#### 외부 단편화(external fragmentation)
가변 크기의 파티션이 생기고 반환되는 여러 번의 과정에서 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상
프로세스의 크기보다 파티션이 작아서 할당되지 않은 공간을 말한다.
![alt text](./[형준]%20Image/image-28.png)


### 연속 메모리 할당의 장단점
#### 장점
- 논리 주소의 물리 주소 변환이 단순하여 CPU의 메모리 액세스 속도 빠르다.
- 운영체제가 관리할 정보량이 적어서 부담이 덜하다.

#### 단점
- 메모리 할당의 유연성이 떨어진다.
  - 작은 홀들을 합쳐보면 프로세스를 할당할 충분한 크기가 있지만 이를 할당하지 못해서 낭비하는 메모리가 발생함

#### 해결 방법
- 메모리 압축(compaction) 기법
  - 중간중간 메모리에서 남는 공간(홀)을 하나의 큰 블록으로 만드는 방법

  ![alt text](./[형준]%20Image/image-32.png)

- 메모리 통합(garbage collection) 기법
  - 인접한 빈 공간을 하나로 합치는 방법

  ![alt text](./[형준]%20Image/image-31.png)


# 분할 메모리 할당 기법은 다음 9, 10장에서 설명하겠다.
## 분할 메모리 할당
> 프로세스를 쪼개어 여러 덩어리(파티션)로 분할해 메모리에 할당

### 고정 크기 할당(페이징)
> 메모리를 고정 크기의 파티션으로 나누고, 프로세스 또한 고정 크기로 나누어 여러 개의 파티션에 분산 저장
![alt text](./[형준]%20Image/image-26.png)

#### 페이징

#### 가상 메모리 페이징


### 가변 크기 할당(세그먼테이션)
> 프로세스를 가변 크기들로 나누고 개별 크기에 맞는 파티션을 메모리에 분산 저장
![alt text](./[형준]%20Image/image-25.png)

#### 세그먼테이션

### 가상 메모리 세그먼테이션