## 하이퍼 링크, 하이퍼 텍스트, HTML
HTTP를 설명하기 위해서는 우선 하이퍼 링크, 하이퍼 텍스트, HTML을 알아야 한다.

www.google.com
위 구글 링크에서 클릭하면 해당 링크로 이동하는 것을 **하이퍼 링크**라고 하며 하이퍼 링크에 사용하는 텍스트를 **하이퍼 텍스트**라고 한다.
하이퍼 텍스트에  HTML(Hyper Text Markup Language) 문서 형식을 사용한다.

- 하이퍼 텍스트 구조
	하이퍼 텍스트를 클릭하면 연결된 HTML 문서로 이동하는 구조이다.
	![alt text](./[형준]%20Image/20231001172451.png)
# HTTP(HyperText Transfer Protocol)
> 서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규약


HTTP는 Hypertext를 전송하는 기술로써 한 문서에서 다른 문서로 이동할 수 있도록 글을 주고 받는 통신 규약으로써 만들어져 사용되어 왔지만 최근에는 거의 모든 형태의 데이터를 전송하는데 사용된다.
- 전송 가능한 데이터들
	- HTML, TEXT
	- 이미지, 음성, 영상, 파일
	- JSOM, XML
	- 거의 모든 형태의 데이터

서버 간에 데이터를 주고 받을 때 대부분 HTTP 프로토콜을 사용한다고 보면 된다.

### HTTP 역사
![alt text](./[형준]%20Image/image.png)
현재는 HTTP1.1이 가장 많이 사용되며 HTTP2와 HTTP3도 많이 사용된다.

- **HTTP/0.9 (1991년)**
  GET 메서드만 지원, HTTP 헤더X
- **HTTP/1.0 (1996년)**
  메서드, 헤더 추가
- **HTTP/1.1 (1997년)**
  가장 많이 사용, 우리에게 가장 중요한 버전
- RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- **HTTP/2 (2015년)**
  성능 개선
- **HTTP/3 (진행중)**
  TCP 대신에 UDP 사용, 성능 개선

##### 기반 프로토콜
가장 최근 나온 HTTP/3는 3-way-handshake를 사용하며 속도가 느린 TCP의 단점을 개선한 UDP 프로토콜을 사용한다.
- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3

- **HTTP/3가 QUIC(UDP 기반)를 사용하는 이유**
	TCP는 3 Way Handshake로 연결하며 신뢰성을 보장하기 위해 데이터 패킷 순서 보장, 패킷 유실 여부 검사 등을 필수로 해야 하기 때문에 속도가 비교적 느리다. 하지만 UDP는 데이터 전송에만 초점을 맞춰 개발했기 때문에 3 Way Handshake, 신뢰성을 위한 기능들을 필수적으로 하지 않아도 되고 사용자가 원하는 것만 커스터마이징하여 할 수 있다. 따라서, TCP 사용으로 인한 딜레이를 줄이기 위해 UDP 프로토콜을 사용했으며 주로 3 Way Handshake에서 발생하는 레이턴시를 줄이는 방식으로 최적화 했다.
	- TCP + TLS(Transport Layer Security : 웹 브라우저 간 통신을 암호화하는 프로토콜)
		![alt text](./[형준]%20Image/20231001175431.png)
	- TCP + TLS vs QUCI(UDP)
		![alt text](./[형준]%20Image/<tcp udp.gif>)
	https://evan-moon.github.io/2019/10/08/what-is-http3/
## HTTP 통신 구조 - 클라이언트 서버 구조
![[Pasted image 20231001214459.png]]
클라이언트가 요청(Request)을 보내면 서버가 응답(Response)를 보내는 방식이다.

### 클라이언트 서버 구조가 생겨난 이유
과거엔 클라이언트(Front-end)와 서버(Back-end)를 나누지 않고 클라이언트에서 모든 것을 처리했다.
비즈니스 로직이 복잡해지고 대용량 데이터가 생겨나면서 각자 역할에만 집중할 수 있도록 클라이언트와 서버로 나누었고 각각 독립적으로 진화가 가능해졌다.
즉, 클라이언트는 비니지스 로직이나 데이터를 다룰 필요 없이 UI를 구현과 사용성에만 집중하고 서버는 복잡한 비지니스 로직과 데이터를 다루는 데만 집중할 수 있게 발전한 것이다.

- **클라이언트(Front-end)**
	사용성, UI 구현에 집중
- **서버(Back-end)**
	비즈니스 로직(서버 아키텍처 설계), 데이터 처리에 집중

## HTTP의 Stateful(상태 유지)와 Stateless(무상태)
### Stateless(무상태 프로토콜)
> 서버가 상태 정보를 유지하지 않는 방식

즉, 클라이언트가 상태 정보를 항상 서버에게 보내주므로 중간에 다른 서버로 바뀌어도 문제없다.
따라서 갑작기 클라이언트의 요청이 증가해도 무한으로 서버 증설이 가능하기 때문에 갑작스러운 클라이언트 요청 증가에 대응하기 좋다.

아래 예시에서 고객이 클라이언트고 점원이 서버라고 생각하면 된다.
한 고객(클라이언트)의 요청을 특정 점원이 기억하지 않고 각 요청을 그때그때 처리하는 방식이다.
기억할 필요가 없기 때문에 여러 점원(서버)이 처리할 수 있는 것이다.

> 고객: 이 <font color="#ff0000">**노트북**</font> 얼마인가요?
> 점원A: 100만원 입니다. 
> 
> 고객: <font color="#ff0000">**노트북**</font> <font color="#ff0000">**2개**</font> 구매하겠습니다. 
> 점원B: 노트북 2개는 200만원 입니다. **<font color="#ff0000">신용카드</font>**, <font color="#ff0000">**현금**</font>중에 어떤 걸로 구매 하시겠어요? 
> 
> 고객: <font color="#ff0000">**노트북**</font> **<font color="#ff0000">2개</font>**를 **<font color="#ff0000">신용카드</font>**로 구매하겠습니다. 
> 점원C: 200만원 결제 완료되었습니다.

![alt text](./[형준]%20Image/20231001221727.png)

![alt text](./[형준]%20Image/20231001221839.png)

- **Stateless의 한계**
	- 로그인이 필요 없는 단순한 서비스 소개 화면은 상태 정보를 저장할 필요가 없기 때문에 Stateless로도 구현이 가능하다. 하지만 페이지가 바뀌어도 로그인이 풀리지 않게 상태 정보를 저장해야 하는 로그인 기능은 Stateless로 구현하기가 까다롭다.
		- 로그인 기능을 Stateless로 구현하는 방법
			쿠키와 세션을 조합하여 로그인 상태를 서버에 유지하는 방법으로 사용한다.
			하지만 세션 서버가 죽거나 쿠키의 데이터가 날아갈 경우 로그인이 풀리기 때문에 완벽한 것은 아니다.

### Stateful(상태 유지)
> 서버가 상태 정보를 유지하는 방식

특정 서버가 상태 정보를 저장하고 있기 때문에 항상 같은 서버가 유지되어야 하고 다른 서버로 바꿀 경우 바뀐 서버는 상태 정보를 알 수 없기 때문에 바꿀 수 없다.


> 고객: 이 **<font color="#ff0000">노트북</font>** 얼마인가요? 
> 점원: 100만원 입니다. **<font color="#ff0000">(노트북 상태 유지)</font>** 
> 
> 고객: **<font color="#ff0000">2개</font>** 구매하겠습니다. 
> 점원: 200만원 입니다. **<font color="#ff0000">신용카드</font>**, <font color="#ff0000">**현금**</font>중에 어떤 걸로 구매 하시겠어요? **<font color="#ff0000">(노트북, 2개 상태 유지)</font>** 
> 
> 고객: **<font color="#ff0000">신용카드</font>**로 구매하겠습니다. 
> 점원: 200만원 결제 완료되었습니다. **<font color="#ff0000">(노트북, 2개, 신용카드 상태 유지)</font>**

![alt text](./[형준]%20Image/20231001221712.png)

- Stateful의 한계
	- 매번 메시지를 보낼 때마다 데이터를 쌓아서 보내야 하기 때문에 데이터를 너무 많이 보내야 하는 문제가 있다.
	- 따라서 꼭 필요한 경우에만 최소한으로만 사용해야 한다.
## 비 연결성(connectionless)
### 연결 유지하는 모델
> 클라이언트와 통신을 하지 않더라도 연결은 계속 유지

- 연결을 유지해야 하기 때문에 자원이 계속 사용된다.

![alt text](./[형준]%20Image/20231001230808.png)
![alt text](./[형준]%20Image/20231001230817.png)
![alt text](./[형준]%20Image/20231001225927.png)
### 연결 유지하지 않는 모델
> 클라이언트와 통신을 할 때만 연결을 유지하고 새로운 클라이언트와 통신을 하려면 기존 클라이언트와 연결을 끊고 새로운 클라이언트와 연결을 한다.

- HTTP는 기본이 연결을 유지하는 않는 모델이다.
- 연결을 유지하지 않아도 돼서 자원을 효율적으로 사용할 수 있다.
- 초 단위 이하의 빠른 속도로 응답할 수 있다. 
- 1시간 동안 수많은 사람들이 서비스를 이용해도 한순간에 동시에 이용하는 게 아니기 때문에 비 연결로 사용하는 것이 효율적이다.
![alt text](./[형준]%20Image/20231001225946.png)
![alt text](./[형준]%20Image/20231001230005.png)
![alt text](./[형준]%20Image/20231001230009.png)
#### 비 연결성 한계
![alt text](./[형준]%20Image/20231001231658.png)
- 매 연결마다 3 Way Handshake를 해야 해서 딜레이 생김
- 웹 브라우저로 사이트를 요청하면 매 요청마다 HTML, 이미지, css 등 다양한 데이터를 다운로드 받기 때문에 요청마다 딜레이 생김

#### 해결 방법
- **HTTP 지속 연결(Persistent Connections)** 사용
	기존 비 연결과 다르게 필요한 자원을 모두 다운 받을 때까지 연결이 종료되지 않고 요청, 응답이 반복된 후 종료된다. 따라서 딜레이가 줄어든다.
	![alt text](./[형준]%20Image/20231001231722.png)
### Stateless를 기억하자
정확히 같은 시간에 대용량 트래픽이 발생하는 경우 생길 수 있다.
(ex. 선착순 이벤트, 수강 신청 00:00 선착순 이벤트 등..)
이럴 경우 무상태 페이지를 이용해서 같은 시간에 접속하는 인원을 분산 시킬 수 있고 Stateless하게 설계하여 그 순간에만 서버를 확 늘려서 대응할 수 있다.
따라서 최대한 Stateless하게 설계하는 것이 중요하다.

## HTTP 메시지
### HTTP 메시지 구조
공백 라인은 필수로 있어야 한다.
![alt text](./[형준]%20Image/20231001232842.png)
![alt text](./[형준]%20Image/20231001233217.png)
### 시작 라인
**HTTP 요청 메시지**(request-line)
<font color="#ff0000">GET /search?q=hello&hl=ko HTTP/1.1</font>
- HTTP 메서드 -> **GET**
	서버가 수행해야 할 동작 지정
	GET, POST, PUT, DELETE 등
	- GET : 리소스 조회
	- POST : 요청 내역 처리
- 요청 대상  -> **/search?q=hello&hl=ko**
	절대경로[?쿼리]
- HTTP 버전 -> **HTTP/1.1**

**HTTP 응답 메시지**(status-line)
<font color="#ff0000">HTTP/1.1 200 OK</font>
- HTTP 버전 -> **HTTP/1.1**
- HTTP 상태 코드 -> **200**
	요청 성공 or 실패를 나타냄
	- 200 : 성공
	- 400 : 클라이언트 요청 오류
	- 500 : 서버 내부 오류
- 이유 문구 -> **OK**
	HTTP 상태 코드를 사람이 이해할 수 있도록 설명하는 글
	200 = 성공 -> OK로 표
### HTTP 헤더
HTTP 전송에 필요한 모든 부가 정보가 포함되어 있다.
ex. 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보...
즉, 메시지 바디에 들어있지 않은 필요한 모든 메타 데이터가 포함되어 있다.

**HTTP 헤더 형태**
header-field = field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)

**HTTP 요청 메시지**
<font color="#ff0000">Host: www.google.com</font>
field-name = **Host**
OWS field-value OWS = **www.google.com**

**HTTP 응답 메시지**
<font color="#ff0000">Content-Type: text/html;charset=UTF-8</font>
<font color="#ff0000">Content-Length: 3423</font>
field-name = **Content-Type / Content-Length**
OWS field-value OWS = **text/html;charset=UTF-8 / 3423**

### HTTP 메시지 바디
실제 전송할 모든 데이터
HTML 문서, 이미지, 영상, JSON, 압축된 데이터 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

![alt text](./[형준]%20Image/20231002211008.png)
# HTTP 메서드

## HTTP API를 만들어보자
### API URI 설계
- **회원** 목록 조회
- **회원** 조회
- **회원** 등록
- **회원** 수정
- **회원** 삭제

URI를 설계할 때 가장 중요한 것은 **리소스를 식별**하는 것이다.
즉, "**회원**"이라는 리소스만 식별하면 되는 거지 조회, 등록, 수정, 삭제는 URI를 설계할 때 고려 사항이 아니다.(명사에 주목, 동사는 HTTP 메서드를 이용해서 식별)

**틀린 예시**

![alt text](./[형준]%20Image/20231003045556.png)

**올바른 예시**

![alt text](./[형준]%20Image/20231003050050.png)

### URI 식별 -> 리소스와 행위 분리
하지만 리소스만 이용해서 URI를 설계한다면 각 기능들을 구별할 수 없다. 이러한 문제를 어떻게 해결할까? -> **리소스와 행위를 분리**한다.

리소스(명사) : 회원
	URI 설계에 사용
행위(동사) : 조회, 등록, 수정, 삭제
	HTTP 메서드를 이용해 구분

## HTTP 메서드 - GET, POST
### GET : 리소스 조회
![alt text](./[형준]%20Image/20231003051134.png)
- **서버에 전달하고 싶은 데이터는 쿼리(URL의 일부)를 통해서 전달**한다. 
	- 예시: https:www.google.com/search?q=hello&hi=ko 에서 ?q=hello&hi=ko이 쿼리이다.
- 메시지 body를 이용해서 데이터를 전달할 수도 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다.
	![alt text](./[형준]%20Image/20231003051248.png)
	![alt text](./[형준]%20Image/20231003051258.png)
	
### POST : 요청 데이터 처리, 주로 등록에 사용
- **메시지 바디를 통해서 서버로 요청 데이터 전달**한다.(<-> GET)
- 서버는 요청 데이터를 처리한다.
- 주로 전달된 데이터로 신규 리소스를 등록하거나 프로세스 처리에 사용한다.

> [!NOTE] POST 사용 예시
> - HTML FORM에 입력한 정보로 회원 가입, 주문 등
> - 게시판 글쓰기, 댓글 달기
> - 신규 주문 생성(새로운 리소스 생성)
> - 문서 끝에 내용 추가(기존 리소스에 데이터 추가)


> [!NOTE] 최종 정리
> 1. 새로운 리소스 생성(등록)
> 	서버가 아직 식별하지 않은 새로운 리소스 생성
> 2. 요청 데이터 처리
> 	- 데이터 생성, 변경을 넘어서 프로세스를 처리하는 경우
> 	예) 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
> 	- POST의 결과로 새로운 리소스가 생성되지 않을 수 있음
> 	예) POST /orders/{orderId}/start-delivery (컨트롤 URI) -> 리소스만으로 힘들면 컨트롤 URI 사용
> 3. 다른 메서드로 처리하기 애매한 경우(GET)
> 	JSON으로 조회 데이터를 넘겨야 하는 경우 -> GET은 메시지 바디를 지원하지 않는 경우가 많아서 GET으로 조회가 힘듬
> 	이때 POST 사용해서 조회 데이터 넘김


![alt text](./[형준]%20Image/20231003051329.png)


![alt text](./[형준]%20Image/20231003051450.png)
![alt text](./[형준]%20Image/20231003051452.png)
![alt text](./[형준]%20Image/20231003051503.png)


### PUT : 리소스를 대체, 해당 리소스가 없으면 생성
- 리소스 덮어쓰기
	- 리소스가 없으면 생성
	- 리소스가 있으면 대체
- 클라이언트가 리소스를 식별한다.(클라이언트가 리소스의 위치를 알고 지정해줌)
	클라이언트가 리소스의 위치(`/member/100`)를 URI에 지정해서 요청
	- POSTsms 클라이언트가 리소스 위치 모른다.
	![[Pasted image 20231003052821.png]]

#### 리소스가 있는 경우-> 리소스 대체(덮어쓰기)
![alt text](./[형준]%20Image/20231003052953.png)
![alt text](./[형준]%20Image/20231003052956.png)
#### 리소스가 없는 경우 -> 신규 리소스 생성
![alt text](./[형준]%20Image/20231003052959.png)
![alt text](./[형준]%20Image/20231003053001.png)
#### 리소스가 있는데 필드가 맞지 않는 경우 -> 완전 대체
![alt text](./[형준]%20Image/20231003053158.png)
![alt text](./[형준]%20Image/20231003053206.png)

### PATCH : 리소스 부분 변경(수정하기)
- 리소스 부분 변경
- PUT은 부분 변경이 불가능하고 아예 대체를 해버리기 때문에 PATCH가 부분 변경 역할을 함
![alt text](./[형준]%20Image/20231003053337.png)
![alt text](./[형준]%20Image/20231003053339.png)

### DELETE : 리소스 삭
![alt text](./[형준]%20Image/20231003053432.png)

![alt text](./[형준]%20Image/20231003053430.png)

### HTTP 기타 메서드
- HEAD
- OPTIONS
- CONNECT
- TRACE
## HTTP 메서드의 속성
### 안전성(Safe Methods)
- HTTP 메서드를 호출해도 리소스가 변하지 않는 것을 안전하다고 한다.
- 계속 호출해서 로그가 쌓여서 **장애**가 발생하는 것은 **리소스 변화**와 관련이 없으므로 고려하지 X
- 즉, 대상 **리소스의 변경 여부만을 고려**한다.
- GET은 읽기만 하고 쓰기는 하지 않기 때문에 안전한 메서드라고 볼 수 있다. 
### 멱등성(Idempotent Methods)
- HTTP 메서드를 한 번 호출하든 N번 호출하든 결과가 똑같은 것을 의미한다.
#### 멱등 메서드
- **GET** 
	여러번 조회해도 결과 같음(변화X)
- **PUT**
	붙여넣기 기능이라서 여러번 호출해도 결과는 항상 같음
	같은 요청을 N번 붙여넣기해도 계속 이전 요청을 대체하기 때문에 최종 결과는 같아짐.
	ex. A 파일을 B 폴더에 계속 붙여넣기하면 결과는 항상 B
- **DELETE**
	계속 같은 삭제 요청을 하면 결과는 항상 삭제된 결과 하나이다.
	ex. A 파일을 삭제하라는 요청을 N번 보내면 첫번째 요청에 삭제하고 이후 요청은 무시되므로 결과는 같음
- **~~POST**~~
	여러 번 호출하면 결과가 중복해서 여러 개 발생할 수 있음
	ex. 회원 등록을 여러 번 요청 -> 회원 N개 생성
	ex. 결제 여러 번 요청 -> 결제가 여러 번 됨
#### 멱등성 활용
- **자동 복구 메커니즘**
	멱등 메서드는 여러 번 요청해도 상관 없기 때문에 만약 요청에 실패했을 때 다시 요청하도록 하는 자동 복구 메커니즘에 사용할 수 있음
	ex. 서버가 정상 응답 못 줬을 때, 클라이언트는 계속해서 같은 요청을 할 수 있음
#### 멱등성 유의할 점
- 외부 요인으로 중간에 리소스가 변경되는 것까진 고려하지 않는다.
- 즉, **동일한 사용자**가 **같은 요청**을 반복하는 것만 가능하다.
	ex. 중간에 **다른 사용자**(사용자2)가 **다른 요청**(PUT)을 해서 리소스가 변경되는 것은 멱등성을 헤친다고 보지 않는다. 
	![alt text](./[형준]%20Image/20231003054458.png)
### 캐시가능(Cacheable Methods)
- 응답 결과는 브라우저 내부에서 캐시해서 사용할 수 있음
- 캐시 가능한 메서드 -> 주로 GET, HEAD만 사용
	- **GET**
	- **HEAD**
	- POST
	- PATCH
	- POST, PATCH는 메시지 body까지 캐시 키로 고려하기 힘들기 때문에 구현이 힘들어서 잘 사용하지X

# HTTP 메서드 활용
## 클라이언트에서 서버로 데이터 전송
### 데이터 전달 방식은 크게 2가지
1. **쿼리 파라미터를 통한 데이터 전송**
	- GET
	- 주로 정렬 필터(검색어)에 사용
2.  **메시지 바디를 통한 데이터 전송**
	- POST, PUT, PATCH
	- 회원 가입, 상품 주문, 리소스 등록, 리소스 변경에 사용
### 4가지 상황
##### 정적 데이터 조회
- 쿼리 파라미터 사용 X, 메시지 바디 사용 X, 리소스 경로만 지정해서 조회 가능
	/static/star.jpg <- 클라이언트가 직접 경로를 지정해서 GET 요청
- 이미지, 정적 텍스트 문서 조회
- '조회'니깐 GET 사용
![alt text](./[형준]%20Image/20231003232023.png)
##### 동적 데이터 조회
- 쿼리 파라미터 사용 O, 메시지 바디 사용 X
- 주로 검색, 게시판 목록에서 정렬 필터(검색어)에 사용
	즉, 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 사용
- '조회'니깐 GET 사용
![alt text](./[형준]%20Image/20231003232252.png)
##### HTML Form을 통한 데이터 전송
**- 데이터 조회 : GET**
	메시지 body를 사용하지 않고 쿼리 파라미터로 데이터 전송(조회만 가능)
	![alt text](./[형준]%20Image/20231003232754.png)
	- 저장(변경)에는 GET 사용하지 않음. POST 사용해야 함.
	![alt text](./[형준]%20Image/20231003232850.png)
**- 데이터 변경 : POST**
	- Content-Type: application/x-www-form-urlencoded 사용
	 - 회원 가입, 상품 주문, 데이터 변경 등에 사용
	- form의 내용을 메시지 바디를 통해 key=value, 쿼리 파라미터 형식으로 전송
	- 전송 데이터를 url encoding 처리
		ex. abc김 -> abc%EA%B9%
	![alt text](./[형준]%20Image/20231003232637.png)
**- multipart/form-data**
	- Content-Type: multipart/form-data
	- 여러 종류의 여러 파일(content-type 데이터)과 폼의 내용을 보낼 때 사용(주로 파일 전송(바이너리 데이터)에 사용)
		ex. jpg, png, 동영상 type 등... -> 바이너리 데이터(이진 byte) 형식으로 표현
	![alt text](./[형준]%20Image/20231003233106.png)
	
##### HTTP API를 통한 데이터 전송
- Content-Type: application/json을 주로 사용 (사실상 표준)
	XML, TEXT도 사용은 가능한데 거의 JSON 사용함
- 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax : HTML에서 Forn 전송 대신 자바 스크립트를 통한 통신에 사용)
- 회원 가입, 상품 주문, 데이터 변경 등에 사용
![alt text](./[형준]%20Image/20231003234639.png)
## HTTP API 설계 예시
HTTP API 설계는 크게 3가지로 나눌 수 있다.
<font color="#ff0000">1. POST 기반 등록 - 컬렉션</font>
	대부분 스토어보단 컬렉션을 사용
	ex. 회원 관리 API
<font color="#ff0000">2. PUT 기반 등록 - 스토어</font>
	대부분 컬렉션 사용, 파일 정도만 스토어 사용
	ex. 정적 컨텐츠 관리, 원격 파일 관리
<font color="#ff0000">3. HTML FORM - 컨트롤 URL</font>
	웹 페이지 회원 관리
	GET, POST만 지원
	컨트롤 URL : 리소스로 URI 설계하고 HTTP 메소드로 동작을 정의하는 것이 불가능할 때 사용

우리가 주목해서 봐야할 부분은 아래 두 가지이다.
	-  POST 기반과 PUT 기반의 차이점
	- HTML Form의 컨트롤 URL
### POST 기반 컬렉션 - 회원 관리 시스템
- 회원 목록 /members -> GET
- 회원 <font color="#ff0000">등록</font> /members -> <font color="#ff0000">POST</font>
- 회원 조회 /members/{id} -> GET
- 회원 <font color="#ff0000">수정</font> /members/{id} -> PATCH, PUT, <font color="#ff0000">POST</font>
	- PATCH : 부분 수정
	- PUT : 덮어쓰기(주로 게시물 수정, 댓글 수정 같이 내용 전체를 바꿔야 할 경우 사용)
	- <font color="#ff0000">POST</font> : 그 외 요청에 대한 처리
- 회원 삭제 /members/{id} -> DELETE

##### POST 신규 자원 등록 특징
- 클라이언트는 등록될 리소스의 URI 모름
- 서버가 새로 등록된 리소스 URI 생성
> [!example] 예시
> 클라이언트는 /members 밖에 모름
> ![alt text](./[형준]%20Image/20231004024736.png)
> 서버가 새로 등록된 리소스 URI 생성(/member<font color="#ff0000">/100</font>)
> ![alt text](./[형준]%20Image/20231004024719.png)
> ![alt text](./[형준]%20Image/20231004024722.png)



- 컬렉션( <-> 스토어)
	- 서버가 관리하는 리소스 디렉토리
	- 서버가 리소스의 URI 생성하고 관리
	- 여기서 컬렉션은 /members
### PUT 기반 스토어 - 파일 관리 시스템
- 파일 목록 /files -> GET
- 파일 조회 /files/{filename} -> GET
- 파일 <font color="#ff0000">등록</font> /files/{filename} -> <font color="#ff0000">PUT</font>
- 파일 삭제 /files/{filename} -> DELETE
- 파일 <font color="#0070c0">대량 등록</font> /files -> <font color="#0070c0">POST</font>

##### PUT 신규 자원 등록 특징
- 클라이언트가 리소스 URI를 알고 있다.
- 클라이언트가 직접 리소스 URI 지정한다.

> [!NOTE] 예시
> 클라이언트가 리소스 URI를 알고 서버에 전체 리소스 URI를 보냄(/members/100)
> ![alt text](./[형준]%20Image/20231004025441.png)
> 클라이언트가 보낸 리소스 URI 그대로를 서버에 등록
> ![alt text](./[형준]%20Image/20231004025443.png)

- 스토어( <-> 컬렉션)
	- 클라이언트가 관리하는 리소스 저장소
	- 클라이언트가 리소스의 URI를 알고 관리
	- 여기서 스토어는 /file
### HTML FORM 사용 컨트롤 URL - 회원 관리 시스템
 - HTML FORM은 <font color="#ff0000">GET</font>, <font color="#ff0000">POST</font>만 지원하고 PUT, PATCH, DELETE는 지원 X
 - AJAX 같은 기술을 사용해서 해결할 수 있지만 여기선 순수 HTML, HTML FORM에 관한 내용이기 때문에 일단 배제
 - So, GET, POST만 지원하기 때문에 발생하는 제약을 <font color="#ff0000">컨트롤 URI</font>를 이용해서 해결한다.
##### 컨트롤 URI를 사용하는 이유
- HTML FORM은 GET, POST만 지원하기 때문에 URI를 설계하는 데 제약이 있음
	- ex. 삭제, 수정 -> DELETE, PATCH로만 가능
	- ex. 결제 등.. -> DELETE, PATCH, PUT으로도 불가능
- 이러한 HTTP 메서드로 해결하기 애매한 경우 동사를 직접 사용하는 컨트롤 URI를 사용
- 최대한 리소스로 URI 설계하고 그래도 안될 때 대체제로써 사용해야 함(이유 모르겠음)
- HTTP API에서도 HTTP 메소드로 표현하지 못할 경우 대체제로써 컨트롤 URI 사용

> [!example] 컨트롤 URL 예시
> - 회원 목록 /members -> GET
> - 회원 등록 폼 /members/new -> GET
> - 회원 등록 /members/<font color="#ff0000">new</font>, /members -> POST
> - 회원 조회 /members/{id} -> GET
> - 회원 수정 폼 /members/{id}/edit -> GET
> - 회원 수정 /members/{id}/<font color="#ff0000">edit</font>, /members/{id} -> POST
> - 회원 삭제 /members/{id}/<font color="#ff0000">delete</font> -> POST
## 참고하면 좋은 URL 설계 개념
![alt text](./[형준]%20Image/20231004034206.png)
# HTTP 상태코드
## 1xx
요청이 수신되어 처리중
거의 사용하지 않아서 설명하지 않음
## 2xx : 요청 정상 처리
클라이언트의 요청을 성공적으로 처리했다는 뜻이다.
### 200 OK
- 클라이언트의 요청을 정상적으로 처리했다는 뜻이다.
![alt text](./[형준]%20Image/20231005103530.png)
### 201 Create
- 요청이 정상적으로 처리됐고 새로운 리소스가 생성됐다는 뜻이다.
- 새롭게 생성된 리소스 URI를 HTTP 헤더에 Location으로 넣어서 응답한다.
![alt text](./[형준]%20Image/20231005103517.png)
### 202 Accepted
요청 접수는 잘 처리 되었지만 아직 처리 완료는 안됐다는 뜻이다.
주로 배치 처리 같은 곳에 사용되며 클라이언트의 요청을 접수만 하고 나중에 처리할 때 사용한다.
실무에서는 잘 사용하지 않는다.
### 204 No Content
서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없다는 뜻이다.

> [!NOTE] 웹 문서 편집기에 값을 입력하고 save 버튼을 누르는 경우
> 보통 문서 작업을 하면 수시로 저장 버튼을 누르게 되는데 저장 버튼을 누를 때마다 응답 메시지가 온다면 불편할 것이다. 잘 저장 됐다는 것만 알면 되고 현재 화면을 그대로 유지하는 것이 사용자 입장에서 편하다. 이렇게 요청이 잘 처리 됐다는 것만 알려주고 따로 응답 데이터를 보내지 않는 것이 204이다.

## 3xx : 리다이렉션
3xx : 클라이언트의 요청을 완료하기 위해서 유저 에이전트(웹 브라우저)의 추가 조치가 필요하단 메시지
### 리다이렉션이란?
웹 브라우저는 서버의 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다.
> [!NOTE] 예시
> 응답 결과에 Location: /new-event가 있다. 웹 브라우저는 Location 헤더에 있는 새로운 URI인 /new-event로 자동으로 리다이렉트한 후 서버에 새로운 URI 주소로 다시 요청을 보낸다.
> ![alt text](./[형준]%20Image/20231005131106.png)


리다이렉션은 크게 3가지로 나뉜다.
1. 영구 리다이렉션
2. 일시 리다이렉션
3. 특수 리다이렉
### 영구 리다이렉션
- 특정 리소스의 URI가 영구적으로 이동한다.
	- ex. /members -> /users 
	- ex. /event -> /new-event
- 실무에서 301을 주로 사용하는 이유는?
	새로운 URI로 바뀌면 내부적으로 전달해야 하는 데이터가 다 바뀌게 된다. 그래서 사용자가 보낸 본문을 그대로 새로운 URI로 보내면 정상적으로 처리되지 않는다. 따라서 실무에서는 일반적으로 사용자가 새로운 URI에서 다시 요청을 보낼 수 있도록 본문을 전부 지우고 POST를 GET으로 바꾸는 301을 사용한다.
#### 301 Moved Permanently
리다이렉트시 요청 메소드가 GET으로 변함
본문(메시지 바디)가 제거될 수 있음(100% 제거되는 것은 아님)

> [!NOTE]
> 클라이언트가 보낸 URI를 event에서 new-event로 리다이렉트하면서 요청 메소드는 POST에서 GET으로 바뀌고 본문(name=hello&age=20)이 제거됨
> ![alt text](./[형준]%20Image/20231005144803.png)

> [!NOTE] 사용 예시
> 사용자가 이번 이벤트 페이지에 접속해서 이벤트 참여 신청을 했다고 생각해보자.
> 이때 서버는 새로운 URI를 사용자에게 리다이랙트를 하고 사용자의 웹 브라우저는 사용 메서드를 GET으로 변경하여 새로운 URI로 다시 요청을 보낸다.

이렇게 301을 사용하면 사용자가 새로운 페이지에서 다시 입력을 하고 다시 요청해야 하는 문제가 발생한다. 이러한 문제를 해결해 주는 것이 308이다.

#### 308 Permanent Redirect
리다이렉트시 요청 메소드와 본문을 유지한다.( <-> 301 : 요청 메소드 GET으로 변경, 본문 변경할 수 있음)

> [!NOTE]
> 클라이언트가 보낸 URI(/event)를 새로운 URI(/new-event)로 리다이렉트하고 처음 클라이언트가 보낸 메소드와 본문(메시지 바디)를 유지한다.
> ![alt text](./[형준]%20Image/20231005144759.png)



> [!NOTE] 사용 예시
> 사용자가 이번 이벤트 페이지에 접속해서 이벤트 참여 신청을 했다고 생각해보자.
> 301과 마찬가지로 새로운 URI로 리다이렉트한다. 이때 301과 다르게 메소드(POST)와 본문(name=hello&age=20)을 그대로 유지한다. 따라서 사용자가 기존의 URI에서 작성한 내용을 자동으로 새로운 URI에 POST해줘서 새로운 URI에서 추가 작성할 필요가 없기 때문에 301보다 편리하다.



### 일시 리다이렉션
- 리소스의 URI가 일시적으로 변경된다.
	- ex. 주문 완료 후 주문 내역 확인 페이지로 이동
- 실무에서는 주로 302를 사용한다.
#### 302 Found
리다이렉트시 요청 메소드가 GET으로 변하고(대부분 변하지만 100% 변하진 않는다), 본문이 제거될 수 있다.
#### 307 Temporary Redirect
리다이렉트시 요청 메소드와 본문을 유지한다.
#### 303 See Other
리다이렉트시 요청 메소드가 GET으로 변한다.(무조껀 변한다)
#### PRG 패턴(Post/Redirect/Get)
POST 요청을 다른 URI로 GET 요청을 하기 위해 리다이렉트 하는 패턴
ex. POST 요청으로 주문을 하면 주문 결과 화면을 보여주기 위해 POST 메소드를 GET 메소드로 바꾸고 주문 페이지를 주문 결과 페이지로 리다이렉트한다.

> [!NOTE] PRG 사용 전 중복 주문 발생 예시
> 1. POST로 주문 후 웹 브라우저에서 새로고침을 한다.
> 2. 새로고침을 할 경우 POST 주문을 다시 요청한다.
> -> 중복 주문 문제가 발생한다.
> ![alt text](./[형준]%20Image/20231005163346.png)


> [!NOTE] PRG 중복 후 주문 해결 예시
> 1. POST로 주문 후 서버가 주문 결과 화면을 GET 메소드로 리다이렉트한다.
> 2. 새로고침해도 주문 결과 화면을 GET으로 조회한다.
> -> 주문을 요청하면 무조껀 주문 결과 화면을 GET 메소드로 리다이렉트하기 때문에 중복 주문 문제를 해결할 수 있다.
> ![alt text](./[형준]%20Image/20231005163432.png)

#### 그래서 뭘 써야 할까?
처음 302 스펙의 의도는 HTTP 메소드를 유지하는 것이었다. 그러나 읟와 다르게 웹 브라우저들이 대부분 GET으로 바꿔버리면서 이 문제를 해결하기위해 명확할 303, 307이 등장했다.

명확한 303, 307을 권장하지만 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하기 때문에 GET으로 변해도 된다면 일반적으로 302를 사용한다.
### 특수 리다이렉션
결과 대신 캐시를 사용한다.
#### 300 Mutiple Choices(안쓴다)
#### 304 Not Modified
- 캐시를 목적으로 사용한다.
- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다.
	즉, 변경된 부분이 없으니 클라이언트 로컬 캐시에 저장된 것을 재사용하는 것 -> 효율적
- 304 응답은 로컬 캐시를 사용하므로 응답에 메시지 바디를 포함하지 않는다.
- 조건부 GET, HEAD 요청시 사용한다.

## 4xx : 클라이언트 오류
- 클라이언트의 잘못된 요청으로 서버가 요청을 수행할 수 없음을 의미한다.
	즉, 클라이언트가 요청 조건에 맞지 않는 요청을 할 경우 4xx를 발생시킨다.
- 클라이언트가 잘못된 요청을 하는 거기 때문에 재요청을 아무리 해도 서버는 항상 4xx를 발생시킬 수 밖에 없어서 아무리 재요청을 해도 오류는 해결될 수 없다.
### 400 Bad Request
클라이언트가 잘못된 요청을 해서 서버에서 처리할 수 없음

- 요청 구문이나 메시지 등 오류가 발생한 것
- 클라이언트는 메시지를 올바르게 수정해서 다시 요청을 보내야 한다.
- ex. 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때
### 401 Unauthorized
인증(Authentication) 되지 않음

- 401 오류 발생시 응답 메시지에 WWW-Authenticate 헤더와 함께 인증 방법 설명을 보낸다.
- 참고
	- 인증(Authentication) : 단순이 본인이 누군이지 확인하는 것(로그인 기능)
	- 인가(Authorization) : 권한 부여(admin 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가할 수 있다.)
### 403 Forbidden
서버가 요청을 이해는 했지만 승인을 거부함

- 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우(인증은 받았지만 인가 받지 못한 경우(401 설명))
- ex. 일반 사용자가 로그인은 성공했지만 인가 받지 못한 admin 등급의 리소스에 접근하는 경우
### 404 Not Found
요청한 리소스를 찾을 수 없음

- 클라이언트가 요청한 리소스가 서버에 없는 경우
- 클라이언트가 접근 권한이 없는 리소스에 접근했지만 서버에선 해당 리소스를 숨기고 싶은 경우
## 5xx : 서버 오류
- 서버 문제로 오류 발생( <-> 4xx : 클라이언트 문제로 오류 발생)
- 클라이언트가 계속해서 재시도 하면 성공할 가능성이 있음( <-> 4xx : 클라이언트 문제인 잘못된 요청을 계속 재시도하면 성공할 수 없음)
### 500 Internal Sever Error
서버 문제로 오류 발생
애매한 경우 500
### 503 Service Unavailable
서비스 이용 불가

- 서버기 일시적인 과부하 or 예정된 작업으로 지금 잠시 요청을 처리할 수 없음
- Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음
	즉, 몇 시부터 몇 시까지 서버 다운을 할 예정이니 몇 시부터 가능하다는 것을 알려준다는 뜻
	But 예정된 작업이 아닌 경우 현실적으로 장애는 예측이 안되므로 일반적으로 500을 사용함